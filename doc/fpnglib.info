This is fpnglib.info, produced by makeinfo version 6.5 from
fpnglib.texi.


File: fpnglib.info,  Node: What is FPNGlib?,  Next: Getting Started with FPNGlib

1 What is FPNGlib?
******************

FPNGlib is a C library that offers pseudo-random generators in a unified
framework.  As the name implies, its strong point is the availability of
many IEEE 754(1) floating-point random number generators, with the
possibility to control the characteristics of the floating-point numbers
generated (e.g., the amount of subnormal vs.  normal, or the probability
of having a least significant bit of the fractional part to be 1)

   Even though it is entirely written in ISO Standard C99, FPNGlib is,
at present, only supported on UNIX-like systems (GNU/Linux and Mac OS X
are the only two tested environments) due to the tools used for its
configuration, compilation and deployment (_autotools_).

   This manual assumes a basic knowledge of the IEEE 754 standard and
refers to the internal representation of floating-point numbers in
several places.  Readers unfamiliar with the standard may find
beneficial to at least read its Wikipedia entry
(https://en.wikipedia.org/wiki/IEEE_754) first.

   The FPNGlib library contains code from third parties, specifically:
   * xorgens 3.06 (https://maths-people.anu.edu.au/~brent/random.html)
     by Richard Brent, licenced under the GNU General Public License
     (http://www.gnu.org/copyleft/gpl.html);
   * Both 64-bit and 32-bit versions of the Mersenne twister
     (http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html), by
     Takuji Nishimura and Makoto Matsumoto, whose licenses can be found
     in files 'src/mt19937-64.c' and 'src/mt19937ar.c'.

   Additionally, the implementation of the Walker/Vose algorithm in
'src/walker_vose.c' is mostly a reimplementation in C of the Java
version by Keith Schwarz
(<https://www.keithschwarz.com/interesting/code/?dir=alias-method>).
Some code is also directly taken from the GNU GSL 2.6
(https://www.gnu.org/software/gsl/) implementation of the same.

   The FPNGlib library is licensed under the terms of the GNU Lesser
General Public License v.3 or later
(https://www.gnu.org/licenses/lgpl-3.0.en.html), except from third party
code, which comes with its own license.  More information about the
FPNGlib library can be found at the project homepage,
<https://gitlab.univ-nantes.fr/goualard-f/fpnglib>.

A Word of Caution
=================

FPNGlib does not contain any truly random number generator as its focus
is on reproducibility for applications such as Monte-Carlo algorithms.
As a consequence, it is not suited for cryptographic applications.

Reporting a Bug
===============

Questions and bug reports shall be directly submitted on the GitLab
platform (https://gitlab.univ-nantes.fr/goualard-f/fpnglib/issues) for
the project.

   ---------- Footnotes ----------

   (1) IEEE Standard for Floating-Point Arithmetic.  IEEE STD 754-2008.
IEEE Computer Society, 2008.


File: fpnglib.info,  Node: Getting Started with FPNGlib,  Next: General Organization of the Library,  Prev: What is FPNGlib?

2 Getting Started with FPNGlib
******************************

This chapter describes the very first steps with FPNGlib, from the
retrieval of the archive to the first program you will write to test its
potential.  If you are accustomed to working with autotools-based
software, feel free to proceed directly to *note An Introduction to
FPNGlib::.

* Menu:

* An Introduction to FPNGlib::

2.1 Installation
================

The FPNGlib library uses the _autotools_ (autoconf
(https://www.gnu.org/software/autoconf/), automake
(https://www.gnu.org/software/automake/), libtool
(https://www.gnu.org/software/libtool/)) for configuration, compilation,
and deployment.  However, these tools do not need to be present on your
computer as long as you do not modify the configuration files
('configure.ac' and the various 'Makefile.am' files, mostly).

   The library is entirely written in the ISO/IEC 9899:1999 C language.
Therefore, its compilation requires a sufficiently recent C compiler
such as any GNU C Compiler v. 4.5 or higher.

   In order to test the library, you will need to install 'check' v.
0.11.0 or higher (<https://libcheck.github.io/check/>) beforehand.  If
your compiler does not support the macro '__VA_OPT__', some tests will
not be performed.  That macro should be available in GCC version 8 and
above, and in Clang version 6 and above.

   Before compiling the library, you need to configure it.  This is done
by calling the command "'./configure'" in the root directory of FPNGlib.
The command accepts many options, among them:

     '--help': display a list of all the options available;
     '--prefix=<PATH TO INSTALL INTO>': give the path to install the
     code into.  The header files will go into an 'include/'
     subdirectory, while the library will go into a 'lib/' subdirectory;
     '--enable-debug=[YES/INFO/PROFILE/NO]': define whether the code
     should be compiled with debug information and assertion support.
     The default is 'no'.  Debug information and assertions may slightly
     impact the performances of the library if enabled.
   There are many other options, shared by all autotools-based
applications.  Use "'./configure --help'" to get the complete list.

   Once the configuration is complete, you may call "'make'" in the root
directory of FPNGlib to compile the library.

   After having compiled the library, you should test it, in order to
ensure that everything is ok.  This is done by calling "'make check'."
If no error is detected, you may proceed to the installation phase.

   The library should be installed before being used.  However, if you
want to get a taste of it beforehand, you may modify and execute the
examples in the subdirectory 'examples/', even before the installation.
Calling "'make'" in this directory will recompile the necessary files.

   The installation is done by calling "'make install'" from the top
directory of the distribution.  By default, the library is installed
into '/usr/local'.  As seen above, this can be changed by using the
'--enable-debug' option at configuration time.


File: fpnglib.info,  Node: An Introduction to FPNGlib,  Up: Getting Started with FPNGlib

2.2 An Introduction to FPNGlib
==============================

FPNGlib offers generators for random integers and for both single
precision and double precision random IEEE 754 floating-point numbers
("floats", for short).  We will first see how to obtain random integers
in *note Generating Random Integers:: and *note Generating Random
Integers in a Domain::, and then random floats in *note Generating
Random Floating-Point Numbers:: and *note Generating a random float with
some properties::.

* Menu:

* Generating Random Integers::
* Generating Random Integers in a Domain::
* Generating Random Floating-Point Numbers::
* Generating a random float with some properties::


File: fpnglib.info,  Node: Generating Random Integers,  Next: Generating Random Integers in a Domain,  Up: An Introduction to FPNGlib

2.2.1 Generating Random Integers
--------------------------------

Our very first program using FPNGlib simply draws one integer at random:

// doc/snippets/isimple.c
#include <stdio.h>
#include <fpnglib/mt19937ar.h>

const uint32_t seed = 13;

int main(void)
{
  fpngl_irng32_t *irng32 = fpngl_mt19937v32(seed);
  printf("%u\n",fpngl_irng32_next32(irng32));
  printf("%lu\n",fpngl_irng32_next64(irng32));
  fpngl_irng32_delete(irng32);
}

   Assuming you have installed FPNGlib locally in some directory
'$HOME/local' by configuring it with the command './configure
--prefix=$HOME/local', you may compile the example above by calling
'gcc' as such:

     gcc -I$HOME/local/include -L$HOME/local/lib \
           -o simple simple.c -lfpnglib

   Of course, if both the _include_ directory and the _lib_ directory
paths appear in the relevant environment variables ('C_INCLUDE_PATH' and
'LD_LIBRARY_PATH', respectively), you may omit the "'-I'" and "'-L'"
directives entirely.  Alternatively, as long as you work on the example
file provided in the 'doc/snippets' directory of the distribution of the
library, you may simply call 'make isimple' to compile it.

   The output of this program should be:
3340206418
11203470090111516746

   In the example above, we use the 32-bit version of the Mersenne
Twister MT19937(1), but FPNGlib also offers the 64-bit version, declared
in 'fpnglib/mt19937-64.h'.

   Random integers come in two sizes: 32-bit and 64-bit.  As exemplified
in the example above, both sizes may be created by 32-bit generators as
well as 64-bit ones: A 32-bit generator will combine two outputs to
return a 64-bit integer; on the other hand, a 64-bit generator will
usually split its output into two 32-bit integers and return one of them
to produce a 32-bit integer.

   All Random Number Generators ("RNG") may be initialized by a single
integer, the _seed_.  In addition, some may be initialized by other
means, mostly vectors of integers.  It is the case with the Mersenne
Twister MT19937, of which an instance may be created with the
'fpngl_mt19937v32_by_array' function instead of 'fpngl_mt19937v32'.
Both functions return a pointer to an object of the opaque type
'fpngl_irng32_t'.  Since the implementation of that type is not public,
all object of the type must be manipulated through pointers only.  This
is the rule for most types in FPNGlib.

   By calling the function 'fpngl_irng32_next32', we compute the next
32-bit integer.  When calling the function 'fpngl_irng32_next64', the
next two 32-bit integers are computed and combined to produce one 64-bit
integer.

   The call to 'fpngl_mt19937v32' allocates some memory from the heap to
represent the internal structure of the MT19937 RNG. We need to call
'fpngl_irng32_delete' to reclaim that memory when the RNG is no longer
used.

   The 32-bit MT19937 RNG instance was constructed and initialized with
the 'fpngl_mt19937v32' constructor.  By using a different constructor,
one may choose a different RNG for ones program without having to modify
it, apart from the constructor call.

   ---------- Footnotes ----------

   (1) 'Mersenne Twister: A 623-dimensionally equidistributed uniform
pseudorandom number generator, M. Matsumoto and T. Nishimura. ACM Trans.
on Modeling and Computer Simulation, 8(1), 1998.'
(http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/earticles.html)


File: fpnglib.info,  Node: Generating Random Integers in a Domain,  Next: Generating Random Floating-Point Numbers,  Prev: Generating Random Integers,  Up: An Introduction to FPNGlib

2.2.2 Generating Random Integers in a Domain
--------------------------------------------

A 32-bit Integer RNG ("IRNG", for short) will usually draw an integer in
the domain [0,2^{32}-1] or in some other smaller but still impractically
large domain.  More often than not, simulations require drawing integers
in some precise domain, say [1,6] to simulate a dice, for example.  For
such an application, many sources still suggest to draw an integer in
the full domain of the RNG and then use the modulo to restrict the
output to the correct domain:
// doc/snippets/biased_dice.c
// WARNING: wrong solution!
#include <stdio.h>
#include <fpnglib/mt19937ar.h>

const uint32_t seed = 13;

int main(void)
{
  fpngl_irng32_t *irng32 = fpngl_mt19937v32(seed);
  printf("%u\n",(fpngl_irng32_next32(irng32) % 6) + 1);
  fpngl_irng32_delete(irng32);
}

   However, since 2^{32} = 6\times 715827882 + 4, there are 715827883
ways to produce the numbers 1 to 4, and only 715827882 ways to produce
the numbers 5 and 6, which introduces a 1.397\times 10^{-7}% bias.  A
very small bias indeed, but one that could become significant if one
used a different RNG, such as a _Linear Congruential Generator_(1)
("LCG") with a congruence much smaller than 2^{32}.

   With FPNGlib, the proper way to generate a random integer in the
domain [0,k], is to use the 'fpngl_ubound32' or 'fpngl_ubound64'
functions available in 'fpnglib/irange.h', depending on the type of
integer expected ('uint32_t' or 'uint64_t'):

// doc/snippets/dice.c
#include <stdio.h>
#include <fpnglib/mt19937ar.h>
#include <fpnglib/irange.h>

const uint32_t seed = 13;

int main(void)
{
  fpngl_irng_t *irng = fpngl_irng_new32(fpngl_mt19937v32(seed));
  printf("%u\n",fpngl_ubound32(irng,6) + 1);
  fpngl_irng_delete(irng);
}
   Remember that the function 'fpngl_mt19937v32' creates a 32-bit RNG
with type 'fpngl_irng32_t'.  The 'fpngl_ubound32' function computes a
random integer in [0,k-1], given k as its second argument.  However, it
must accept to do so with both a 32-bit RNG and a 64-bit RNG. We
therefore need to encapsulate the actual 32-bit RNG into a "generic" RNG
of type 'fpngl_irng_t' with the function 'fpngl_irng_new32'.  The 'irng'
variable owns the 32-bit RNG it encapsulates and is responsible for its
deletion, which will be done when we call 'fpngl_irng_delete' instead of
'fpngl_irng32_delete'.

   The 'fpngl_ubound32' function uses the modification by O'Neill(2) of
Lemire's algorithm(3) to draw integers in an interval.  The
'fpngl_ubound64' uses the same algorithm, provided a 128 bits integer
type is available on the platform used.  Otherwise, it uses slower
methods presented by O'Neill at
<https://www.pcg-random.org/posts/bounded-rands.html>.

   To draw integers from a domain [a,b] instead of [0,k], one can use
the functions 'fpngl_range32' and 'fpngl_range64'.

   ---------- Footnotes ----------

   (1) '<https://en.wikipedia.org/wiki/Linear_congruential_generator>'.

   (2) Efficiently Generating a Number in a Range, Melissa E. O'Neil,
<https://www.pcg-random.org/posts/bounded-rands.html>, 2018.

   (3) Fast Random Integer Generation in an Interval, Daniel Lemire, ACM
TOMACS 29(1), 2019.


File: fpnglib.info,  Node: Generating Random Floating-Point Numbers,  Next: Generating a random float with some properties,  Prev: Generating Random Integers in a Domain,  Up: An Introduction to FPNGlib

2.2.3 Generating Random Floating-Point Numbers
----------------------------------------------

One of the strong points of FPNGlib is the generation of IEEE 754
floating-point numbers(1).  It offers many methods to draw floats in
different domains and with various properties.

   In the following example, we use an RNG that computes a double
precision floating-point number in [0,1) by drawing first an integer in
[0,2^{53}-1] and then dividing it by 2^{53}.

// doc/snippets/fsimple.c
#include <stdio.h>
#include <fpnglib/mt19937-64.h>
#include <fpnglib/irng_t.h>
#include <fpnglib/frng64_division_k.h>

const uint32_t seed = 13;

int main(void)
{
  fpngl_frng64_t *frng64 = fpngl_div53(fpngl_irng_new64(
                                         fpngl_mt19937v64(seed)));
  printf("Min: %a, Max: %a\n",
         fpngl_frng64_min(frng64),
         fpngl_frng64_max(frng64));
  printf("%a\n",fpngl_frng64_nextf64(frng64));
  fpngl_frng64_delete(frng64);
}

   The output of the 'fpngl_frng64_nextf64' function expressed using the
C99 hexadecimal format(2) is "'0x1.ba7451f95b40fp-1'."

   Floating-point number generators ("FRNG"s, for short) are either of
the type 'fpngl_frng32_t' when they produce single precision floats, or
'fpngl_frng64_t' for double precision.  In the same way as for integer
generators, floats generators can only be manipulated through pointers
to objects of these types.  All generators of either type must implement
the same functionalities.  In particular, as shown in *note Example 2.1:
exa:mcpi. and in the example above, double precision generators must
implement the following calls:
   * 'fpgnl_frng64_name()': return a constant string corresponding to
     the name of the generator;
   * 'fpngl_fnrg64_nextf64()': return the next double precision random
     number;
   * 'fpngl_frng64_min()': return the smallest floating-point value that
     can be computed by the FRNG;
   * 'fpngl_frng64_max()': return the largest floating-point value that
     can be computed by the FRNG;
   * 'fpngl_frng64_delete()': reclaim the memory used to represent the
     generator.
   As a consequence, it is possible to write functions requiring random
floats independently of the FRNG actually used, and to pass it as a
parameter (see, e.g., 'mcpi' in *note Example 2.1: exa:mcpi.).

   Note, however, that FRNGs are not bound to return floats in any
prescribed domain: some may return values in "[0,1)," some in "(0,1),"
and some others in any other domain.  It is then the responsibility of
the programmer to choose FRNGs according to the domains they are
interested into.  Contrary to the custom in the literature on the
subject, FPNGlib does not report the domain of an FRNG in terms of an
interval with possibly open bounds; since FRNGs compute discrete values
and not real ones, it is always possible for the functions
'fpngl_frng64_min' and 'fpngl_frng64_max' to return the minimum and
maximum that may actually be reached.  For example, the 'fpngl_div53'
RNG is able to return all floating-point numbers of the form
{k\times2^{-53}\mid k\in{0, 1, \dots, 2^{53}-1}}.  Consequently, its
minimum reported is 0 and its maximum 1-2^{-53}.

   A classical way to implement FRNGs is to rely on an integer RNG and
divide its output by some integer constant, usually the largest possible
integer the RNG can produce or the next integer above.  This is what we
do to create 'frng0' in *note Example 2.1: exa:mcpi, in which we use a
Monte Carlo method to compute with two different RNGs an approximation
of \pi by throwing virtual darts at a unit circle and counting the ones
that land in it: firstly, we create an IRNG based on the 32-bit version
of the Mersenne Twister MT19937, then we create an FRNG by using the
'fpngl_bydivision_new64' constructor.  That constructor takes three
parameters:
  1. A name for the newly created FRNG ("'FMT19937v32'," in *note
     Example 2.1: exa:mcpi.);
  2. An IRNG of the type 'fpngl_irng_t';
  3. A divisor by which each random integer should be divided (here, we
     choose to divide by the smallest integer strictly larger than the
     largest random number that our IRNG can produce, therefore creating
     a FRNG returning values in [0,1)(3)).

   Note that, as is always the case in FPNGlib, the FRNG 'frng0' created
from the IRNG 'irng32' "owns" it and is, therefore, responsible for its
destruction.  This is why we do not call 'fpngl_irng_delete' at the end
of the program: the call 'fpngl_frng64_delete(frng0)' is sufficient to
reclaim both the memory allocated to represent 'frng0' and 'irng32'.

   The FRNG created with 'fpngl_drand48bsd' also relies on the division
of the result of a Linear Congruential Generator by a constant integer.
The result is a floating-point number in [0,1) with 48 bits of entropy
only.

// doc/snippets/mcpi.c
#include <stdio.h>
#include <math.h>
#include <fpnglib/frng64_division.h>
#include <fpnglib/mt19937ar.h>
#include <fpnglib/irng_t.h>

#define NITERS 10000000
const uint64_t seed = 13;
const double m_pi = 0x1.921fb54442d18p+1;

// Estimating the value of pi by throwing darts at a unit circle.
double mcpi(fpngl_frng64_t *frng, uint32_t niters)
{
  uint32_t in_circle = 0;
  for (uint32_t i = 0; i < niters; ++i) {
    double x = fpngl_frng64_nextf64(frng);
    double y = fpngl_frng64_nextf64(frng);
    in_circle += ((x*x + y*y) <= 1);
  }
  return 4*((double)in_circle / niters);
}

int main(void)
{
  fpngl_irng_t *irng32 = fpngl_irng_new32(fpngl_mt19937v32(seed));
  fpngl_frng64_t *frng0 = fpngl_bydivision_new("FMT19937v32",irng32,
                                               fpngl_irng_max(irng32)+1);
  fpngl_frng64_t *frng1 = fpngl_drand48bsd(seed);
  printf("%s: %.16g\n",fpngl_frng64_name(frng0), mcpi(frng0,NITERS));
  printf("%s: %.16g\n",fpngl_frng64_name(frng1), mcpi(frng1,NITERS));
  fpngl_frng64_delete(frng0);
  fpngl_frng64_delete(frng1);
}

Example 2.1: Computing an approximation to \pi with a Monte Carlo
method.

   ---------- Footnotes ----------

   (1) IEEE Standard for Floating-Point Arithmetic.  IEEE STD 754-2008.
IEEE Computer Society, 2008.

   (2) See Section 6.4.4.2 of ISO/IEC 9899:1999.

   (3) As a side note, the open bound is guaranteed only if the divisor
is smaller than 2^{53}, which is the case here since we use a 32-bit
IRNG.


File: fpnglib.info,  Node: Generating a random float with some properties,  Prev: Generating Random Floating-Point Numbers,  Up: An Introduction to FPNGlib

2.2.4 Generating a random float with some properties
----------------------------------------------------

For some applications, we are interested in drawing floating-point
numbers with some definite properties only.  That might be:
   * Only subnormal floats;
   * Only normal floats;
   * Subnormal and normal floats in some precise proportion;
   * Only positive floats with exponents and fractional parts in some
     precise domain;
   * ...

   FPNGlib is particularly well suited for this kind of applications as
it offers many ways to define the properties the floats should meet.

   For example, if only random double precision subnormal floats are
required, one can use the 'fpngl_denormal64' function.  For random
normal floats, the 'fpngl_normal64' function can be used:

// doc/snippets/subnormal.c
#include <stdio.h>
#include <fpnglib/float64.h>
#include <fpnglib/mt19937-64.h>

const uint64_t seed = 42;

int main(void)
{
  fpngl_irng_t *irng = fpngl_irng_new64(fpngl_mt19937v64(seed));
  printf("Random denormal: %g\n",fpngl_denormal64(irng));
  printf("Random normal: %g\n",fpngl_normal64(irng));
  fpngl_irng_delete(irng);
}

   Both functions require an integer RNG, as the subnormal and normal
random floats are constructed from their exponent and fractional part
fields.

   FPNGlib considers five classes of floats:
   * \pm0;
   * Subnormal;
   * Normal;
   * \pm\infty;
   * _Not a Number_.
   There are generator functions for each of theses classes.  In
addition, using the 'fpngl_class_float64_new' function, it is easy to
draw floats from these five classes with different probabilities
attached to each:
// doc/snippets/distrib.c
#include <stdio.h>
#include <fpnglib/float64.h>
#include <fpnglib/mt19937-64.h>

const uint64_t seed = 42;

int main(void)
{
  fpngl_irng_t *irng = fpngl_irng_new64(fpngl_mt19937v64(seed));
  fpngl_distribution_t *dist = fpngl_class_float64_new(irng,
                                   (double[]){0.125,0.25,0.5,0.125,0.0});
  for (uint32_t i = 0; i < 10; ++i) {
    printf("%g\n",fpngl_float64_distrib(dist));
  }
  fpngl_distribution_delete(dist);
}
   This program displays 10 floats, with probabilities 12.5% that they
are equal to \pm0, 25% that they are subnormal, 50% that they are
normal, and 12.5% that they are infinite.

   Note that the object of type 'fpngl_distribution_t' owns the RNG IRNG
and is responsible for its destruction.  This is why we only call
'fpngl_distribution_delete' to delete the DIST object, and not
'fpngl_irng_delete' on IRNG.

   A more flexible way to draw floats from a specific set is to put
constraints on the acceptable sign, exponent and fractional part with
the 'fpngl_float64' function.  The following program, for example, will
draw 10 double precision floats in '[2,4)':
// doc/snippets/float64.c
#include <stdio.h>
#include <fpnglib/constants64.h>
#include <fpnglib/float64.h>
#include <fpnglib/mt19937-64.h>

const uint64_t seed = 13;

int main(void)
{
  fpngl_irng_t *irng = fpngl_irng_new64(fpngl_mt19937v64(seed));
  for (uint32_t i = 0; i < 10; ++i) {
    printf("%g\n",fpngl_float64(irng, fpngl_positive, 1024, 1024,
                                fpngl_minfrac64, fpngl_maxfrac64,
                                fpngl_noand64, fpngl_noor64));
  }
  fpngl_irng_delete(irng);
}
   The first parameter of 'fpngl_float64' is an integer RNG, which is
used to draw the integers defining the sign, exponent and fractional
part of the float returned.  The second parameter indicates what is the
expected sign of the float drawn; It can be one of:
   * 'fpngl_positive' (for drawing only positive floats);
   * 'fpngl_negative' (for drawing only negative floats);
   * 'fpngl_whatever' (for either positive or negative floats, with an
     equiprobability of both).
   The third and fourth parameters establish bounds on the _biased_
exponent(1).  The fifth and sixth parameters establish bounds on the
possible values of the fractional part, with 'fpngl_minfrac64' being the
smallest possible value, equal to '0x0000000000000', and
'fpngl_maxfrac64' being the largest possible value, equal to
'0xfffffffffffff'.  Lastly, the seventh and eighth parameters are masks
that are ultimately applied to the fractional part: the seventh
parameter is "anded" with the fractional part and the eighth parameter
is "ored" with that resulting value.

   In the example above, we are asking for floats with a positive sign,
an exponent of '1' (1024 minus the bias of 1023) and a fractional part
between '0x0000000000000' and '0xfffffffffffff', that is --in binary--
floats from +1.0\times2^1 to
+1.111111111111111111111111111111111111111111111111111\times2^1, or in
decimal, from 2.0 to 4.0-2^{-51}.

   ---------- Footnotes ----------

   (1) The _biased_ exponent e for double precision floats takes its
value in [0,2047], the actual exponent E being equal to e-1023.


File: fpnglib.info,  Node: General Organization of the Library,  Next: Integer Random Generators,  Prev: Getting Started with FPNGlib

3 General Organization of the Library
*************************************

In FPNGlib, all public constants, variables, types, and functions are
prefixed with 'fpngl_' to make them stand apart in larger programs and
avoid name collisions.  All header files from FPNGlib are in the
subdirectory 'fpnglib/'.

   All RNGs have types whose name is formed according to the same
principle: first the prefix 'fpngl_', then the type of the RNG ('irng'
for an RNG generating integers, and 'frng' for an RNG generating
floating-point numbers) followed by the size of the values returned
('32' for 32-bit integers and single precision floating-point numbers,
and '64' for 64-bit integers and double precision floating-point
numbers), and finally the postfix '_t' to mark the name as a type.  A
slight exception to this scheme is the type 'fpngl_irng_t' that can wrap
32-bit as well as 64-bit integer RNGs.

   There are at present five Random Number Generator types in FPNGlib:
   * 'fpngl_irng32_t'.  RNG generating 32-bit integers natively;
   * 'fpngl_irng64_t'.  RNG generating 64-bit integers natively;
   * 'fpngl_irng_t'.  Wrapper for a RNG generating natively either
     32-bit or 64-bit integers;
   * 'fpngl_frng32_t'.  RNG generating single precision (C type
     "'float'") IEEE 754 floating-point numbers;
   * 'fpngl_frng64_t'.  RNG generating double precision (C type
     "'double'") IEEE 754 floating-point numbers.
   Note that both 32-bit and 64-bit integer RNGs can generate 32-bit as
well as 64-bit integers with, respectively, the functions
'fpngl_irng32_next64' and 'fpngl_irn64_next32'.

   The complete state of all the RNGs is entirely contained in an object
of one of the abovementioned types.  There are no global variables,
which means that the user may define and use several RNGs, even of the
same type, without any risk of interferences between them.


File: fpnglib.info,  Node: Integer Random Generators,  Next: Floating-Point Random Generators,  Prev: General Organization of the Library

4 Integer Random Generators
***************************

In this chapter, we present the Random Number Generators capable of
producing 32-bit as well as 64-bit integers.  They all follow a uniform
distribution.  Refer to *note Non-Uniform Distributions:: for other
distributions.

   Random Number Generators that produce integers must all provide the
same services independently of the size of the integers they "natively"
produce:
   * Compute a 32-bit integer;
   * Compute a 64-bit integer;
   * Compute k random bits, with k being smaller than the size of the
     integers produced natively by the RNG;
   * Compute an array of 32-bit integers;
   * Compute an array of 64-bit integers;
   * Return the seed used to initialize the RNG;
   * Return the minimum integer the RNG can produce;
   * Return the maximum integer the RNG can produce.

   In addition, an RNG must possess a function to release the resources
acquired upon construction of an instance.  Each RNG type has its own
constructor (*Note Integer RNGs available::).

   In the following, we describe the functions providing these services
for RNGs of the type 'fpngl_irng32_t', 'fpngl_irng64_t', as well as for
the wrapper type 'fpngl_irng_t'.  The services specific to this last
type are described in *note Unsized RNGs::.

 -- 'fpnglib/irng32_t.h': void fpngl_irng32_delete (fpngl_irng32_t* RNG)
 -- 'fpnglib/irng64_t.h': void fpngl_irng64_delete (fpngl_irng64_t* RNG)
 -- 'fpnglib/irng_t.h': void fpngl_irng_delete (fpngl_irng_t* RNG)
     Releases the resources acquired upon the construction of the RNg
     RNG.  The parameter RNG must point to an RNG not already released,
     otherwise the behavior is undefined.

 -- 'fpnglib/irng32_t.h': uint32_t fpngl_irng32_next32 (fpngl_irng32_t*
          RNG)
 -- 'fpnglib/irng64_t.h': uint32_t fpngl_irng64_next32 (fpngl_irng64_t*
          RNG)
 -- 'fpnglib/irng_t.h': uint32_t fpngl_irng_next32 (fpngl_irng_t* RNG)
     Return the next 32-bit random integer.  A 64-bit RNG will usually
     compute a 64-bit integer and return the lower or higher 32 bits.

     The behavior is undefined if RNG does not point to some valid RNG.

 -- 'fpnglib/irng32_t.h': uint64_t fpngl_irng32_next64 (fpngl_irng32_t*
          RNG)
 -- 'fpnglib/irng64_t.h': uint64_t fpngl_irng64_next64 (fpngl_irng64_t*
          RNG)
 -- 'fpnglib/irng_t.h': uint64_t fpngl_irng_next64 (fpngl_irng_t* RNG)
     Return the next 64-bit random integer.  A 32-bit RNG will be called
     twice to create a 64-bit integer.

     The behavior is undefined if RNG does not point to some valid RNG.

 -- 'fpnglib/irng32_t.h': uint32_t fpngl_irng32_nextk (fpngl_irng32_t*
          RNG, uint32_t K)
 -- 'fpnglib/irng64_t.h': uint64_t fpngl_irng64_nextk (fpngl_irng64_t*
          RNG, uint32_t K)
 -- 'fpnglib/irng_t.h': uint64_t fpngl_irng_nextk (fpngl_irng_t* RNG,
          uint32_t K)
     Return the next K random bits.  The maximum value of K depends on
     the type of RNG:
        * K\in[0,32] for a 32-bit RNG;
        * K\in[0,64] for a 64-bit RNG;
        * K\in[0,64] for a wrapped RNG of type 'fpngl_irng_t'.

     Note that K may be greater than 32 for a 32-bit RNG when it is
     wrapped in an RNG of type 'fpngl_irng_t'.  In that case, the RNG is
     called twice and the two outputs are aggregated to form the result.

 -- 'fpnglib/irng32_t.h': void fpngl_irng32_array32 (fpngl_irng32_t*
          RNG, uint32_t* T, uint32_t N)
 -- 'fpnglib/irng64_t.h': void fpngl_irng64_array32 (fpngl_irng64_t*
          RNG, uint32_t* T, uint32_t N)
 -- 'fpnglib/irng_t.h': void fpngl_irng_array32 (fpngl_irng_t* RNG,
          uint32_t* T, uint32_t N)
     Fill the array T with N 32-bit random integers.  The array T must
     have been allocated to the correct size before the call.

     The speed-up obtained with this function, compared with calling N
     times a '*_next32' function depends on the RNG used.  For most
     implementations, a 64-bit RNG will be called at most N/2 times and
     each 64-bit integer split into two 32-bit integers to fill adjacent
     positions in the array.  Some RNGs do have dedicated fast
     implementations of this function (refer to their documentation).

 -- 'fpnglib/irng32_t.h': void fpngl_irng32_array64 (fpngl_irng32_t*
          RNG, uint64_t* T, uint32_t N)
 -- 'fpnglib/irng64_t.h': void fpngl_irng64_array64 (fpngl_irng64_t*
          RNG, uint64_t* T, uint32_t N)
 -- 'fpnglib/irng_t.h': void fpngl_irng_array64 (fpngl_irng_t* RNG,
          uint64_t* T, uint32_t N)
     Fill the array T with N 64-bit random integers.  The array T must
     have been allocated to the correct size before the call.

     The speed-up obtained with this function, compared with calling N
     times a '*_next64' function depends on the RNG used.  For most
     implementations, a 32-bit RNG will be called 2N times.  Some RNGs
     do have dedicated fast implementations of this function (refer to
     their documentation).

 -- 'fpnglib/irng32_t.h': uint32_t fpngl_irng32_seed (fpngl_irng32_t*
          RNG)
 -- 'fpnglib/irng64_t.h': uint64_t fpngl_irng64_seed (fpngl_irng64_t*
          RNG)
 -- 'fpnglib/irng_t.h': uint64_t fpngl_irng32_seed (fpngl_irng_t* RNG)
     Return the value used to initialize the RNG. Some RNGs are not
     initialized by a single integer value (e.g., the 32-bit MT19937 RNG
     created with 'fpngl_mt19937v32_by_array').  In that case, that
     function will return "'0'."

 -- 'fpnglib/irng32_t.h': const char* fpngl_irng32_name (fpngl_irng32_t*
          RNG)
 -- 'fpnglib/irng64_t.h': const char* fpngl_irng64_name (fpngl_irng64_t*
          RNG)
 -- 'fpnglib/irng_t.h': const char* fpngl_irng_name (fpngl_irng_t* RNG)
     Return a pointer to a constant string representing the name of the
     RNG. Refer to each constructor in *note Integer RNGs available:: to
     know the possible values.

 -- 'fpnglib/irng32_t.h': uint32_t fpngl_irng32_min (fpngl_irng32_t*
          RNG)
 -- 'fpnglib/irng64_t.h': uint64_t fpngl_irng64_min (fpngl_irng64_t*
          RNG)
 -- 'fpnglib/irng_t.h': uint64_t fpngl_irng_min (fpngl_irng_t* RNG)
     Return the smallest integer that can be drawn with the RNG.

 -- 'fpnglib/irng32_t.h': uint32_t fpngl_irng32_max (fpngl_irng32_t*
          RNG)
 -- 'fpnglib/irng64_t.h': uint64_t fpngl_irng64_max (fpngl_irng64_t*
          RNG)
 -- 'fpnglib/irng_t.h': uint64_t fpngl_irng_max (fpngl_irng_t* RNG)
     Return the largest integer that can be drawn with the RNG.

 -- 'fpnglib/irng_t.h': bool fpngl_is_irng32 (fpngl_irng_t* RNG)
 -- 'fpnglib/irng_t.h': bool fpngl_is_irng64 (fpngl_irng_t* RNG)
     Return 'true' if the wrapped RNG is, respectively, of the type
     'fpngl_irng32_t' or 'fpngl_irng64_t'.

* Menu:

* Unsized RNGs::
* Integer RNGs available::
* Random Integers in a Range::
* Non-Uniform Distributions::


File: fpnglib.info,  Node: Unsized RNGs,  Next: Integer RNGs available,  Up: Integer Random Generators

4.1 Unsized RNGs
================

Since both 32-bit and 64-bit RNGs can produce 32-bit as well as 64-bit
integers, users may be tempted to write programs that use an RNG,
irrespective of its type.  The 'fpngl_irng_t' type serves as a wrapper
around 32-bit and 64-bit RNGs to abstract their real limitations.  An
object of that type is constructed from an actual RNG of type
'fpngl_irng32_t' or 'fpngl_irng64_t' with, respectively, the functions
'fpngl_irng_new32' and 'fpngl_irng_new64'.  *note Example 4.1: exa:irng.
shows how to write a function 'draw_twice' that takes as input both
32-bit and 64-bit RNGs wrapped in a 'fpngl_irng_t' type.

// doc/snippets/irng.c
#include <stdio.h>
#include <fpnglib/irng_t.h>
#include <fpnglib/xorgens.h>

const uint32_t seed = 13;

void draw_twice(fpngl_irng_t *irng)
{
  printf("%lu\t%lu\n",fpngl_irng_next64(irng), fpngl_irng_next64(irng));
}

int main(void)
{
  fpngl_irng32_t *irng32 = fpngl_xor4096iv32(seed);
  fpngl_irng_t *irng = fpngl_irng_new32(irng32);
  draw_twice(irng);
  fpngl_irng_delete(irng);
  fpngl_irng64_t *irng64 = fpngl_xor4096iv64(seed);
  irng = fpngl_irng_new64(irng64);
  draw_twice(irng);
  fpngl_irng_delete(irng);
}

Example 4.1: Wrapping 32-bit and 64-bit RNGs in a 'fpngl_irng_t' object.

   Note that the new RNG constructed IRNG "owns" the RNG passed as a
parameter to 'fpngl_irng_new32' or 'fpngl_irng_new64' constructor, and
is responsible for its proper disposal.  The release of resources is
then done with 'fpngl_irng_delete' only.

 -- 'fpnglib/irng_t.h': fpngl_irng_t* fpngl_irng_new32 (fpngl_irng32_t*
          IRNG32)
 -- 'fpnglib/irng_t.h': fpngl_irng_t* fpngl_irng_new64 (fpngl_irng64_t*
          IRNG64)
     Wrap an 32-bit or 64-bit RNG into an 'fpngl_irng_t' object.  The
     new object is responsible for the destruction of the RNG passed as
     a parameter.  Consequently, IRNG32 (resp. IRNG64) should not be
     deleted with 'fpngl_irng32_delete' (resp. 'fpngl_irng64_delete')
     afterwards.

   There is also a function to draw an integer of the size supported
natively by the wrapped RNG:

 -- Library Function: uint64_t fpngl_irng_next (fpngl_irng_t* RNG)
     This function is unique to the 'fpngl_irng_t' type.  If the RNG
     wrapped is of type 'fpngl_irng64_t', it behaves like
     'fpngl_irng_next64', otherwise it returns the integer computed with
     'fpngl_irng_next32' cast to 64 bits.


File: fpnglib.info,  Node: Integer RNGs available,  Next: Random Integers in a Range,  Prev: Unsized RNGs,  Up: Integer Random Generators

4.2 Integer RNGs available
==========================

The number of integer Random Number Generators augments regularly with
new versions of FPNGlib.  *note Table 4.1: tab:irngs. summarizes the
characteristics of the integer RNGs implemented in the current version
of the library, with the following meanings for the columns:
   * Name.  The name of the RNG as reported by 'fpngl_irng32_name' for
     the 32-bit RNGs and 'fpngl_irng64_name' for the 64-bit RNGs;
   * Size.  Size, in bits, of the integers that are natively created by
     the RNG;
   * Min.  Value of the smallest integer that can returned by the RNG;
   * Max.  Value of the largest integer that can returned by the RNG;
   * Period.  Number of integers that can be drawn before a sequence
     repeats itself.

Name                          Size        Min.        Max.        Period
------------------------------------------------------------------------------
'drand48_lcg64'               64          0           2^{48}-1    ?
'gnu_lcg64'                   64          0           2^{31}-1    ?
'minstd64'                    64          0           2^{31}-2    ?
'mt19937v32'                  32          0           2^{32}-1    ?
'mt19937v64'                  64          0           2^{64}-1    ?
'mupad_lcg64'                 64          0           10^{12}-12  ?
'randu64'                     64          0           2^{31}-1    ?
'von neumann/metropolis'      32          0           2^{32}-1    ?
'xor4096iv32'                 32          0           2^{32}-1    ?
'xor4096iv64'                 64          0           2^{64}-1    ?

Table 4.1: Integer RNGs available in FPNGlib 0.0.1 and their
characteristics.

4.2.1 32-bit Integer RNGs
-------------------------

The following constructors create an integer RNG initialized with a
seed, which can be one integer or an array of integers.

 -- 'fpnglib/irng32_vnm.h': fpngl_irng32_t* fpngl_von_neumann_metropolis
          (uint32_t SEED)
     Create a 32-bit RNG using the algorithm described in 'Various
     techniques used in connection with random digits. John von Neumann.
     In A.S. Householder, G.E. Forsythe, and H.H. Germond, eds. Monte
     Carlo Method, National Bureau of Standards Applied Mathematics
     Series, vol. 12:pp. 36-38'.

     The value of SEED should be greater than 255, and preferably much
     larger than that, otherwise the RNG will only return 0.

     This is not a very good RNG; it is only provided for its historical
     interest.

 -- 'fpnglib/mt19937ar.h': fpngl_irng32_t* fpngl_mt19937v32 (uint32_t
          SEED)
 -- 'fpnglib/mt19937ar.h': fpngl_irng32_t* fpngl_mt19937v32_by_array
          (const uint32_t INIT_KEY[], uint32_t KEY_LENGTH)
     This is the 32-bit version of the Mersenne Twister MT19937 by
     Nishimura & Matsumoto.  It can be initialized either by a single
     integer, or by an array of integers.  For maximum entropy, the
     array should have a size at least equal to 624, but smaller arrays
     are allowed.

     The function 'fpngl_irng32_seed' will return '0' if the RNG is
     initialized with an array.

 -- 'fpnglib/xorgens.h': fpngl_irng32_t* fpngl_xor4096iv32 (uint32_t
          SEED)
     This is the 32-bit implementation of the 'xor4096i' algorithm by
     Richard P. Brent.

4.2.2 64-bit Integer RNGs
-------------------------

 -- 'fpnglib/lcg.h': fpngl_irng64_t* fpngl_minstd64 (uint64_t SEED)
     MINSTD implementation of Park & Miller Linear Congruential
     Generator:

     See: 'Random Number Generators: Good Ones Are Hard to Find. S. K.
     Park and K.W. Miller. Comm. ACM 31(10), 1988'.

 -- 'fpnglib/lcg.h': fpngl_irng64_t* fpngl_gnuc_lcg64 (uint64_t SEED)
     RNG used in the implementation of the GNU libc 'rand' function:

     This RNG is no longer the default implementation for 'rand' in GNU
     libc as of v.  2.29.

 -- 'fpnglib/lcg.h': fpngl_irng64_t* fpngl_randu64 (uint64_t SEED)
     This is the 64-bit implementation of the RNG called "'RANDU'" in
     the _Scientific Subroutine Package on IBM Mainframe_:

     See: 'Numerical Computing with MATLAB. Steve Moler. Chap. 9'.

 -- 'fpnglib/lcg.h': fpngl_irng64_t* fpngl_drand48_lcg64 (uint64_t SEED)
     RNG used by the GNU and FreeBSD implementations of the function
     'drand48'.  It is also used by 'java.util.Random'.  It is an LCG
     with formula:

 -- 'fpnglib/lcg.h': fpngl_irng64_t* fpngl_mupad_lcg64 (uint64_t SEED)
     RNG used in MuPAD Pro 3.1 and Maple 10.  This is an LCG with
     formula:

 -- 'fpnglib/mt19937-64.h': fpngl_irng64_t* fpngl_mt19937v64 (uint64_t
          SEED)
 -- '"mt19937v64"': fpngl_irng64_t* fpngl_mt19937v64_by_array (const
          uint64_t INIT_KEY[], uint64_t KEY_LENGTH)
     This is the 64-bit version of the Mersenne Twister MT19937 by
     Nishimura & Matsumoto.  It can be initialized either by a single
     integer, or by an array of integers.  For maximum entropy, the
     array should have a size at least equal to 312, but smaller arrays
     are allowed.

     The function 'fpngl_irng_seed' will return '0' if the RNG is
     initialized with an array.

 -- 'fpnglib/xorgens.h': fpngl_irng64_t* fpngl_xor4096iv64 (uint64_t
          SEED)
     This is the 64-bit implementation of the 'xor4096i' algorithm by
     Richard P. Brent.


File: fpnglib.info,  Node: Random Integers in a Range,  Next: Non-Uniform Distributions,  Prev: Integer RNGs available,  Up: Integer Random Generators

4.3 Random Integers in a Range
==============================

Most RNGs of *note Integer RNGs available:: return random integers drawn
from a large domain (typically [0,2^{32}-1] or [0,2^{64}-1]).  Many
applications, however, require random integers from much smaller
domains, e.g., to model dice throwing, coin tossing, ...  An oft quoted
tentative answer to the problem is to use the modulo operation, as in
*note Program 'biased_dice.c': biased_dice_c.  As already discussed for
that program, this approach is biased whenever the number of values in
the original domain of the RNG is not a multiple of the modulus.  Even
if it is a multiple of the modulus, the modulo operation extracts the
low-order bits of the random integer, which are the least "random" ones
for many RNGs.

   FPNGlib offers four different functions to compute random numbers in
a "small" domain, depending on the size of the integers required and the
bounds of the domain: if the domain is of the form "[0,a)", use the
following functions:

 -- 'fpnglib/irange.h': uint32_t fpngl_ubound32 (fpngl_irng_t* RNG,
          uint32_t A)
 -- 'fpnglib/irange.h': uint64_t fpngl_ubound64 (fpngl_irng_t* RNG,
          uint64_t A)
     Use the RNG RNG to draw an integer uniformly at random in the
     domain [0,a).

     These functions use an efficient algorithm by D. Lemire presented
     in '"Fast Random Integer Generation in an Interval." Daniel Lemire.
     ACM Transactions on Modeling and Computer Simulation, 29(1), 2019'
     with modifications by M.E. O'Neill proposed in '"Efficiently
     Generating a Number in a Range".
     <https://www.pcg-random.org/posts/bounded-rands.html>. 2018-07-22.
     [Retrieved 2020-03-12]'.

     The function 'fpngl_ubound64' may be slower when the computer does
     not offer 128 bits integers natively.

     Note that, for both functions, no provision is made to ensure that
     A is smaller than the largest integer that can be computed by RNG,
     'fpngl_irng_max(rng)'.  It is up to the user to check that this
     precondition is met.

   When the domain considered is of the form [a,b), with a and b
potentially negative integers, use the following functions:

 -- 'fpnglib/irange.h': int32_t fpngl_range32 (fpngl_irng_t* RNG,
          int32_t A, int32_t B)
 -- 'fpnglib/irange.h': int64_t fpngl_range64 (fpngl_irng_t* RNG,
          int64_t A, int64_t B)
     Use the RNG RNG to draw integers uniformly at random in the domain
     [A,B).

     These functions rely, respectively, on functions 'fpngl_ubound32'
     and 'fpngl_ubound64' to compute random integers in the domain [0,
     b-a) and then shift it by A.


File: fpnglib.info,  Node: Non-Uniform Distributions,  Prev: Random Integers in a Range,  Up: Integer Random Generators

4.4 Non-Uniform Distributions
=============================

All the RNGs presented in *note Integer RNGs available:: return integers
drawn uniformly at random in their domain of definition.  It is
sometimes necessary to consider other distributions.  At present,
FPNGlib only allows to draw integers from a discrete distribution.
Consider, for example, the modeling of a biased dice with the
probabilities shown in *note Figure 4.1: fig:biased_dice.

Figure 4.1: Biased dice modeled with a discrete probability distribution

// doc/snippets/biased_dice_2.c
#include <stdio.h>
#include <fpnglib/discrete_distribution.h>
#include <fpnglib/mt19937-64.h>
const uint64_t seed = 42;
const uint32_t ndraws = 1000000;
int main(void)
{
  fpngl_irng_t *irng = fpngl_irng_new64(fpngl_mt19937v64(seed));
  fpngl_distribution_t *dist = fpngl_distribution_new(irng,
                                 (double[]){0.1,0.2,0.1,0.1,0.3,0.2}, 6);
  uint32_t draws[6] = {0,0,0,0,0,0};
  for (uint32_t i = 0; i < ndraws; ++i) {
    draws[fpngl_distribution_next32(dist)]++;
  }
  printf("%.3g %.3g %.3g %.3g %.3g %.3g\n",
         draws[0]/(double)ndraws, draws[1]/(double)ndraws,
         draws[2]/(double)ndraws, draws[3]/(double)ndraws,
         draws[4]/(double)ndraws, draws[5]/(double)ndraws);
  fpngl_distribution_delete(dist);
}

Example 4.2: Biased dice with discrete distribution probability for the
faces.

   A discrete probability distribution is created by calling the
'fpnlg_distribution_new' function with an integer RNG and an array of
probabilities as parameters.  It returns an object of type
'fpngl_distribution_t', which can be used to draw 32-bit random integers
following the distribution embodied by the array of probabilities.
*note Example 4.2: exa:biased2. draws NDRAWS values with the loaded dice
from *note Figure 4.1: fig:biased_dice. and computes the probability of
each face to occur.

The output of the program in *note Example 4.2: exa:biased2. is:
0.0999 0.199 0.0999 0.1 0.3 0.2

which is very close to the distribution expected ('[0.1, 0.2, 0.1, 0.1,
0.3, 0.2]').

 -- 'fpnglib/discrete_distribution.h': fpngl_distribution_t*
          fpngl_distribution_new (fpngl_irng_t* RNG, const double P[],
          uint32_t SZP)
     Construct a discrete distribution with probability P'[i]' of
     drawing the integer 'i'.  The array P must have at least SZP
     elements, where SZP must be lower or equal to 2^{30} (The limit on
     SZP is due to the use of the 'uistack_t' type, which has a similar
     implementation-motivated limit).  The sum of all values in P must
     be equal to 1.

     The current implementation uses the Walker/Vose alias method with
     linear complexity.(1)

     The ownership of the integer RNG RNG is transferred to the
     'fpngl_distribution_t' object, which is responsible for its
     disposal.

 -- 'fpnglib/discrete_distribution.h': void fpngl_distribution_delete
          (fpngl_distribution_t* DIST)
     Reclaim the memory allocated to represent a discrete distribution.
     It also reclaims the memory used to represent the RNG passed upon
     its construction.

 -- 'fpnglib/discrete_distribution.h': uint32_t
          fpngl_distribution_next32 (fpngl_distribution_t *DIST)
     Return a random 32-bit integer according to the discrete
     distribution DIST.

   ---------- Footnotes ----------

   (1) '"An Efficient Method for Generating Discrete Random Variables
with General Distributions." A.J. Walker. ACM Transactions on
Mathematical Software. 3 (3): 253–256, 1977' and '"A linear algorithm
for generating random numbers with a given distribution." M.D. Vose.
IEEE Transactions on Software Engineering. 17 (9): 972–975'


File: fpnglib.info,  Node: Floating-Point Random Generators,  Next: IEEE 754 and the Floating-Point Unit,  Prev: Integer Random Generators

5 Floating-Point Random Generators
**********************************

The standard libraries of most programming languages offers only one
algorithm to compute random IEEE 754 floating-point numbers.  Usually,
it computes floats by dividing random integers by some constant.  This
imparts a specific structure to the fractional parts of the floats,
which may adversely impact programs that use them.(1)

   FPNGlib gives the user the choice of the method used to produce
floats.  All float RNGs are either of the type 'fpngl_frng32_t', when
they produce single precision floats, or 'fpngl_frng64_t', for double
precision floats; they must all propose the same functionalities:

 -- 'fpnglib/frng32_t.h': void fpngl_frng32_delete (fpngl_frng32_t* RNG)
 -- 'fpnglib/frng64_t.h': void fpngl_frng64_delete (fpngl_frng64_t* RNG)
     Reclaim the memory allocated to the RNG RNG.  If it was constructed
     with an integer RNG, the memory for that one is also reclaimed
     since float RNGs "own" the integer RNGs they are built with.

 -- 'fpnglib/frng32_t.h': float fpngl_frng32_min (fpngl_frng32_t* RNG)
 -- 'fpnglib/frng32_t.h': float fpngl_frng32_max (fpngl_frng32_t* RNG)
 -- 'fpnglib/frng64_t.h': double fpngl_frng64_min (fpngl_frng64_t* RNG)
 -- 'fpnglib/frng64_t.h': double fpngl_frng64_max (fpngl_frng64_t* RNG)
     Return, respectively, the minimum and the maximum possible values
     drawn by the floating-point RNG.

     In the literature, many FRNGs are described as returning values in
     the domain [0,1).  Technically, their actual domain is not an
     interval but a set of discrete values.  It is then always possible
     to describe the domain with closed brackets.  The functions
     "'*_min'" and "'*_max'" return, respectively, the smallest and
     largest values in this set.

 -- 'fpnglib/frng32_t.h': float fpngl_frng32_nextf32 (fpngl_frng32_t*
          RNG)
 -- 'fpnglib/frng64_t.h': double fpngl_frng64_nextf64 (fpngl_frng64_t*
          RNG)
     Return the next random floating-point number uniformly drawn from,
     respectively, the domain '[fpngl_frng32_min(rng),
     fpngl_frng32_max(rng)]', or the domain '[fpngl_frng64_min(rng),
     fpngl_frng64_max(rng)]'.

 -- 'fpnglib/frng32_t.h': float fpngl_frng32_next_arrayf32
          (fpngl_frng32_t* RNG, float *T, uint32_t N)
 -- 'fpnglib/frng64_t.h': double fpngl_frng64_next_arrayf64
          (fpngl_frng64_t* RNG, double *T, uint32_t N)
     Fill the array T with N random floating-point numbers drawn with
     the FRNG RNG.

     *Caution*: some FRNGs may allocate a temporary array of size
     2\timesN to implement this function.

 -- 'fpnglib/frng32_t.h': const char* fpngl_fprng32_name
          (fpngl_frng32_t* RNG)
 -- 'fpnglib/frng64_t.h': const char* fpngl_fprng64_name
          (fpngl_frng64_t* RNG)
     Return the string corresponding to the name of the FRNG (*Note
     Existing float RNGs::).

 -- 'fpnglib/frng32_t.h': uint32_t fpngl_fprng32_seed (fpngl_frng32_t*
          RNG)
 -- 'fpnglib/frng64_t.h': uint64_t fpngl_fprng64_seed (fpngl_frng64_t*
          RNG)
     Return the integer used to initialize the FRNG.

* Menu:

* Existing float RNGs::
* Drawing floats in a class::
* Drawing floats non-uniformly::

   ---------- Footnotes ----------

   (1) '"Generating Random Floating-Point Numbers by Dividing Integers:
a Case Study", Fre'de'ric Goualard. In proceedings of the International
Conference on Computational Science (ICCS 2020). Lecture Notes in
Computer Science, Springer, June 2020.'


File: fpnglib.info,  Node: Existing float RNGs,  Next: Drawing floats in a class,  Up: Floating-Point Random Generators

5.1 Existing float RNGs
=======================

* Menu:

* Single Precision FRNGs::
* Double Precision FRNGs::


File: fpnglib.info,  Node: Single Precision FRNGs,  Next: Double Precision FRNGs,  Up: Existing float RNGs

5.1.1 Single Precision FRNGs
----------------------------

 -- 'fpnglib/xorgens.h': fpngl_frng32_t* fpngl_xor4096rv32 (uint32_t
          SEED)
     ??


File: fpnglib.info,  Node: Double Precision FRNGs,  Prev: Single Precision FRNGs,  Up: Existing float RNGs

5.1.2 Double Precision FRNGs
----------------------------

 -- 'fpnglib/frng64_division.h': fpngl_frng64_t* fpngl_matlabp5
          (uint64_t SEED)
     Double precision FRNG used by MATLAB until MATLAB 5.

 -- 'fpnglib/frng64_division.h': fpngl_frng64_t* fpngl_drand48bsd
          (uint64_t SEED)
     Implementation of the POSIX function 'drand48' in FreeBSD.

 -- 'fpnglib/frng64_division.h': fpngl_frng64_t* fpngl_mupad (uint64_t
          SEED)
     Generator used in Maple 10 and MuPAD Pro 3.1.

 -- 'fpnglib/frng64_division_k.h': fpngl_frng64_t* fpngl_div53
          (fpngl_irng_t* IRNG, uint64_t SEED)
     Draw a double precision number in the domain
     {0}\cup{2^{-53},1-2^{-53}} by dividing an integer generated with
     the IRNG IRNG by 2^{53}.

 -- 'fpnglib/frng64_division_k.h': fpngl_frng64_t* fpngl_div32
          (fpngl_irng_t* IRNG, uint64_t SEED)
     Draw a double precision number in the domain
     {0}\cup{2^{-32},1-2^{-32}} by dividing an integer generated with
     the IRNG IRNG by 2^{32}.

 -- 'fpnglib/frng64_drand48gnu.h': fpngl_frng64_t* fpngl_drand48gnu
          (uint64_t SEED)
     Implementation of the POSIX 'drand48' function as implemented in
     GNU 'gcc'.

 -- 'fpnglib/frng64_fog97.h': fpngl_frng64_t* fpngl_fog97 (fpngl_irng_t*
          IRNG, uint64_t SEED)
     Computation of a double precision number in [0,1-2^{-52}] by
     generating a 52 bits random fractional part, concatenating it with
     an exponent of 0 to obtain a float in [1,2-2^{-52}], and then
     subtracting 1.0 from it.

 -- 'fpnglib/frng64_fog05.h': fpngl_frng64_t* fpngl_fog05 (fpngl_irng_t*
          IRNG, uint64_t SEED)
     ??

 -- 'fpnglib/frng64_golang.h': fpngl_frng64_t* fpngl_golang
          (fpngl_irng_t* IRNG, uint64_t SEED)
     ??

 -- 'fpnglib/frng64_java.h': fpngl_frng64_t* fpngl_java (uint64_t SEED)
     ??

 -- 'fpnglib/frng64_KGW.h': fpngl_frng64_t* fpngl_KGW (fpngl_irng_t*
          IRNG, uint64_t SEED)
     ??

 -- 'fpnglib/frng64_lecuyer_simard.h': fpngl_frng64_t*
          fpngl_lecuyer_simard (fpngl_irng_t* IRNG, uint64_t SEED)
     ??

 -- 'fpnglib/frng64_rationalLCG10.h': fpngl_frng64_t*
          fpngl_rationalLCG10 (uint64_t SEED)
     ??

 -- 'fpnglib/xorgens.h': fpngl_frng64_t* fpngl_xor4096rv64 (uint64_t
          SEED)
     ??


File: fpnglib.info,  Node: Drawing floats in a class,  Next: Drawing floats non-uniformly,  Prev: Existing float RNGs,  Up: Floating-Point Random Generators

5.2 Drawing floats in a class
=============================

 -- 'fpnglib/float64.h': double fpngl_subnormal64 (fpngl_irng_t* RNG)
     Return a random double precision subnormal number drawn uniformly
     from the domain (-'fpngl_lambda64()', 'fpngl_lambda64()').

 -- 'fpnglib/float64.h': double fpngl_zero64 (fpngl_irng_t* RNG)
     Return zero in double precision as +0.0 or -0.0 with even
     probability.

 -- 'fpnglib/float64.h': double fpngl_inf64 (fpngl_irng_t* RNG)
     Return the double precision value reserved for infinity as +\infty
     or -\infty with even probability.

 -- 'fpnglib/float64.h': double fpngl_normal64 (fpngl_irng_t* RNG)
     Return a random double precision number drawn uniformly in the
     domain [-'fpngl_max64()',
     -'fpngl_lambda64()']\cup['fpngl_lambda64()', 'fpngl_max64()'].

 -- 'fpnglib/float64.h': double fpngl_nan64 (fpngl_irng_t* RNG)
     Return randomly one of the 2^{53}-2 possible _Not-A-Number_ double
     precision values.

 -- 'fpnglib/float64.h': double fpngl_float64 (fpngl_irng_t* RNG,
          fpngl_sign_t S,	uint32_t MINEXP, uint32_t MAXEXP,	uint64_t
          MINFRAC, uint64_t MAXFRAC,	uint64_t ANDMASK,	uint64_t ORMASK)
     Return a random double precision number whose IEEE 754 structure
     (sign, exponent, fractional part) obeys the constraints given as
     parameters:
        * S: possible sign.  May be 'fpngl_positive', 'fpngl_negative',
          or 'fpngl_whatever' if both positive and negative signs are
          allowed;
        * MINEXP: minimum exponent allowed.  This is the biased value,
          which means you must add 1023 to the actual value.  Possible
          values are in the domain [0,2047];
        * MAXEXP: maximum exponent allowed.  This is the biased value,
          which means you must add 1023 to the actual value.  Possible
          values are in the domain [0,2047];
        * MINFRAC: minimum fractional part expressed as a 52 bits
          unsigned integer between '0x0000000000000000' and
          '0x000fffffffffffff';
        * MAXFRAC: maximum fractional part expressed as a 52 bits
          unsigned integer between '0x0000000000000000' and
          '0x000fffffffffffff';
        * ANDMASK: bitwise 'AND' mask applied to the integer obtained by
          concatenating the random sign, biased exponent, and fractional
          part.  Should be 'fpngl_noand64'(1) if no mask is to be
          applied;
        * ORMASK: bitwise 'OR' mask applied to the result of the bitwise
          AND. Should be 'fpngl_noor64'(2) if no mask is needed.

     Note that, for better performances, the consistency of the
     constraints are not tested.

   ---------- Footnotes ----------

   (1) The 'fpngl_noand64' constant has value '0xffffffffffffffff' and
is defined in 'fpnglib/constants64.h'.

   (2) The 'fpngl_noor64' constant has value '0x0000000000000000' and is
defined in 'fpnglib/constants64.h'.


File: fpnglib.info,  Node: Drawing floats non-uniformly,  Prev: Drawing floats in a class,  Up: Floating-Point Random Generators

5.3 Drawing floats non-uniformly
================================

The FPNGlib library proposes a simple way to draw floating-point numbers
from one of the five classes presented in *note Drawing floats in a
class:: according to some discrete probability distribution.  The user
first defines the probability distribution for each of the classes in
the order "'zero, subnormal, normal, infinite, nan'" with the function
'fpngl_class_float64_new'; it is then possible to draw floats following
that distribution with the function 'fpngl_float64_distrib'.  This
functionality is just a facility offered around the more general method
presented in *note Non-Uniform Distributions::.

 -- 'fpnglib/float64.h': fpngl_distribution_t* fpngl_class_float64_new
          (fpngl_irng_t* IRNG, const double P[static 5])
     Create an 'fpngl_distribution_t' object representing the discrete
     probability distribution defined by the array P of at least 5
     values:
        * 'P[0]': probability of returning \pm0.0;
        * 'P[1]': probability of returning a subnormal number;
        * 'P[2]': probability of returning a normal number;
        * 'P[3]': probability of returning \pm\infty;
        * 'P[4]': probability of returning an _NaN_.
     The sum of the first five values in P must be equal to 1.  Note
     that, inside the classes 1 and 2 (subnormal and normal numbers),
     the floats are still drawn uniformly at random.

 -- 'fpnglib/float64.h': double fpngl_float64_distrib
          (fpngl_distribution_t* FPD)
     Return a floating-point number from one of the four classes "zero,
     subnormal, normal, infinite, nan" according to the probability
     distribution FPD.


File: fpnglib.info,  Node: IEEE 754 and the Floating-Point Unit,  Next: Extending the Library,  Prev: Floating-Point Random Generators

6 IEEE 754 and the Floating-Point Unit
**************************************

This chapter describes the various constants, functions and macros
provided by FPNGlib that do not directly contribute to the generation of
random numbers.

6.1 Constants
=============

Several constants related to the characteristics of the IEEE 754
floating-point format are defined in files 'fpnglib/constants32.h' --for
the single precision-- and 'fpnglib/constants64.h' --for the double
precision.

 -- 'fpnglib/constants32.h': const uint32_t fpngl_emin32
 -- 'fpnglib/constants64.h': const uint32_t fpngl_emin64
 -- 'fpnglib/constants32.h': const uint32_t fpngl_emax32
 -- 'fpnglib/constants64.h': const uint32_t fpngl_emax64
     Smallest and largest unbiased exponents for single and double
     precision float.

     *Example*
     // doc/snippets/exponent.c
     #include <stdio.h>
     #include <math.h>
     #include <fpnglib/constants32.h>
     #include <fpnglib/constants64.h>
     
     int main(void)
     {
       printf("Single precision exponent in [%d, %d]\n",
              fpngl_emin32,fpngl_emax32);
       printf("Double precision exponent in [%d, %d]\n",
              fpngl_emin64,fpngl_emax64);
     }
     *Output:*
     Single precision exponent in [-126, 127]
     Double precision exponent in [-1022, 1023]

 -- 'fpnglib/constants32.h': const uint32_t fpngl_t32
 -- 'fpnglib/constants64.h': const uint32_t fpngl_t64
     Number of bits in the significand of a single or double precision
     float.  The "significand" of a float corresponds to the fractional
     part together with the hidden bit before the binary point.

     *Example:*
     // doc/snippets/significand.c
     #include <stdio.h>
     #include <math.h>
     #include <fpnglib/constants32.h>
     #include <fpnglib/constants64.h>
     
     int main(void)
     {
       printf("Number of bits with single precision: %u\n",
     				 fpngl_t32);
       printf("Number of bits with double precision: %u\n",
              fpngl_t64);
       printf("Number of digits with single precision: %u\n",
              (uint32_t)trunc(fpngl_t32*log10(2)));
       printf("Number of digits with double precision: %u\n",
              (uint32_t)trunc(fpngl_t64*log10(2)));
     }
     *Output:*
     Number of bits with single precision: 24
     Number of bits with double precision: 53
     Number of digits with single precision: 7
     Number of digits with double precision: 15

 -- 'fpnglib/constants32.h': const float fpngl_mu32
 -- 'fpnglib/constants64.h': const double fpngl_mu64
     Smallest positive float.  This is a subnormal number.

     Example:
     // doc/snippets/mu.c
     #include <stdio.h>
     #include <math.h>
     #include <fpnglib/constants32.h>
     #include <fpnglib/constants64.h>
     
     int main(void)
     {
       printf("%d\n",nextafterf(0.0f,1.0f) == fpngl_mu32);
       printf("%d\n",nextafter(0.0,1.0) == fpngl_mu64);
     }
     Output:
     1
     1

 -- 'fpnglib/constants32.h': const float fpngl_lambda32
 -- 'fpnglib/constants64.h': const double fpngl_lambda64
     Smallest positive normal float.

     Example:
     // doc/snippets/lambda.c
     #include <stdio.h>
     #include <fpnglib/constants32.h>
     #include <fpnglib/constants64.h>
     
     int main(void)
     {
       printf("Single precision smallest positive normal: %g\n",
              fpngl_lambda32);
       printf("Double precision smallest positive normal: %g\n",
              fpngl_lambda64);
     }
     Output:
     Single precision smallest positive normal: 1.17549e-38
     Double precision smallest positive normal: 2.22507e-308

 -- 'fpnglib/constants32.h': const float fpngl_u32
 -- 'fpnglib/constants64.h': const double fpngl_u64
     "Unit roundoff", which is half the distance between '1.0' and the
     next floating-point number.

     Example:
     // doc/snippets/unitroundoff.c
     #include <stdio.h>
     #include <fpnglib/constants32.h>
     #include <fpnglib/constants64.h>
     
     int main(void)
     {
     	printf("Single precision unit roundoff: %g\n",fpngl_u32);
     	printf("Double precision unit roundoff: %g\n",fpngl_u64);
     }
     Output:
     Single precision unit roundoff: 5.96046e-08
     Double precision unit roundoff: 1.11022e-16

 -- 'fpnglib/constants32.h': const float fpngl_max32
 -- 'fpnglib/constants64.h': const double fpngl_max64
     Largest positive finite float.

     Example:
     // doc/snippets/max.c
     #include <stdio.h>
     #include <fpnglib/constants32.h>
     #include <fpnglib/constants64.h>
     
     int main(void)
     {
       printf("Single precision largest float: %g\n",fpngl_max32);
       printf("Double precision largest float: %g\n",fpngl_max64);
     }
     Output:
     Single precision largest float: 3.40282e+38
     Double precision largest float: 1.79769e+308

 -- 'fpnglib/constants32.h': const float fpngl_NaN32
 -- 'fpnglib/constants64.h': const double fpngl_NaN64
     Return a _Not a Number_.

     Example:
     // doc/snippets/nan.c
     #include <stdio.h>
     #include <fpnglib/constants32.h>
     #include <fpnglib/constants64.h>
     
     int main(void)
     {
       printf("Single precision NaN: %g\n",fpngl_NaN32);
       printf("Double precision NaN: %g\n",fpngl_NaN64);
     }
     Output:
     Single precision NaN: nan
     Double precision NaN: nan

 -- 'fpnglib/constants32.h': const float fpngl_infinity32
 -- 'fpnglib/constants64.h': const double fpngl_infinity64
     Infinity value.

     Example:
     // doc/snippets/inf.c
     #include <stdio.h>
     #include <fpnglib/constants32.h>
     #include <fpnglib/constants64.h>
     
     int main(void)
     {
       printf("Single precision infinity: %g\n",fpngl_infinity32);
       printf("Double precision infinity: %g\n",fpngl_infinity64);
     }
     Output:
     Single precision infinity: inf
     Double precision infinity: inf

 -- 'fpnglib/constants64.h': const uint64_t fpngl_minfrac64
 -- 'fpnglib/constants64.h': constant uint64_t fpngl_maxfrac64
     Minimum and maximum value for the fractional part of a 64-bit
     double precision floating-point number.  These constants are mainly
     used when calling 'fpngl_float64' to draw floats with some
     properties.

     Example:
     // doc/snippets/minmaxfrac64.c
     #include <stdio.h>
     #include <fpnglib/constants64.h>
     
     int main(void)
     {
       printf("minfrac64: %lx\n",fpngl_minfrac64);
       printf("maxfrac64: %lx\n",fpngl_maxfrac64);
     }
     Output:
     minfrac64: 0
     maxfrac64: fffffffffffff

 -- 'fpnglib/constants64.h': const uint64_t fpngl_noand64
 -- 'fpnglib/constants64.h': const uint64_t fpngl_noor64
     Masks to use with the function 'fpng_float64' when no _and_ mask
     (resp. no _or_ mask) is needed for the fractional part of the
     floats constructed.

     Example:
     // doc/snippets/noandor.c
     #include <stdio.h>
     #include <fpnglib/constants64.h>
     
     int main(void)
     {
       printf("noand64 mask: %lx\n",fpngl_noand64);
       printf("noor64 mask: %lx\n",fpngl_noor64);
     }
     Output:
     noand64 mask: ffffffffffffffff
     noor64 mask: 0

6.2 Utility Functions
=====================

FPNGlib defines functions that can aid in computing the floating-point
numbers an application requires.

 -- 'fpnglib/float64.h': double fpngl_nextafter64 (double V, uint64_t N)
     Return a double precision number that is N floating-point numbers
     _after_ V on the real line.

     The value of N must be smaller or equal to '0xffe0000000000000'.
     The function will abort if N is greater than that and the library
     has been compiled with '--enable-debug=yes'.  Otherwise, the
     behavior is undefined.

     If V is an NaN, the function returns the same NaN. Otherwise, it
     returns either a finite float or a positive infinite, depending on
     the value of N and the distance of V to the maximum representable
     double precision float.

     Example:
     // doc/snippets/nextafter64.c
     #include <stdio.h>
     #include <fpnglib/constants64.h>
     #include <fpnglib/float64.h>
     
     int main(void)
     {
       printf("%d\n",fpngl_nextafter64(1.0, 1L<<52) == 2.0);
     }
     The output is '1' since there are 2^{52} floats from '1.0' to '2.0'
     in double precision.

 -- 'fpnglib/float64.h': double fpngl_previous64 (double V, uint64_t N)
     Return a double precision number that is N floating-point numbers
     _before_ V on the real line.

     The value of N must be smaller or equal to '0xffe0000000000000'.
     The function will abort if N is greater than that and the library
     has been compiled with '--enable-debug=yes'.  Otherwise, the
     behavior is undefined.

     If V is an NaN, the function returns the same NaN. Otherwise, it
     returns either a finite float or a positive infinite, depending on
     the value of N and the distance of V to the maximum representable
     double precision float.

     Example:
     // doc/snippets/previous64.c
     #include <stdio.h>
     #include <fpnglib/constants64.h>
     #include <fpnglib/float64.h>
     
     int main(void)
     {
       printf("%d\n",fpngl_previous64(fpngl_mu64, 2) == -fpngl_mu64);
     }
     The output is '1' since the smallest positive double precision
     float is separated from the largest negative float by '0'.

 -- 'fpnglib/float64.h': uint64_t fpngl_distance_float64 (double A,
          double B)
     Return the number of floats (bounds included) from value A to value
     B.  Return '1' if 'A==B' and '0' if either A or B are not finite
     floats (infinities or NaNs).

     The function is only defined for 'A <= B'.

 -- 'fpnglib/float64.h': uint64_t fpngl_signed_distance_float64 (double
          A, double B)
     Return the number of floats (bounds included) from value A to value
     B.  Return '1' if 'A==B' and '0' if either A or B are not finite
     floats (infinities or NaNs).  Return a negative value if 'A < B'.

6.3 Manipulating the FPU
========================


File: fpnglib.info,  Node: Extending the Library,  Next: Function Index,  Prev: IEEE 754 and the Floating-Point Unit

7 Extending the Library
***********************

The library is written with an object-oriented style that should make it
easy to extend.

 [image src="fpnglib-figures/classes.jpg" text="" ]

Figure 7.1: The "classes" of FPNGlib

   Functions with "'_internal'" in their name are for internal use in
the library and should not be used outside of its realm.

7.1 Debugging facilities
========================

FPNGlib offers facilities to debug itself.  There are in particular some
macros that can be used to display messages to the standard error ouput
'stderr', provided the library was configured with the option
'--enable-debug=yes' (the default) or '--enable-debug=info' for some
macros.

 -- 'fpnglib/debug.h': FPNGL_DEBUG (...)
     Uses 'fprintf' to output its arguments to 'stderr' if the macro
     'NDEBUG' is defined to '1'.  Otherwise, it does nothing.

     The macro flushes the output buffer with 'fflush' after each call.

     Example:
     // doc/snippets/debug.c
     #include <fpnglib/debug.h>
     
     int main(void)
     {
       double a = 1.0;
       FPNGL_DEBUG("This will be displayed only in debug mode: %g\n",a);
     }

 -- 'fpnglib/debug.h': FPNGL_WARNING (...)
     Displays a warning message to 'stderr' if the library was
     configured with either '--enable-debug=yes' or
     '--enable-debug=info'.

     The macro flushes the output buffer with 'fflush' after each call.

     Example:
     // doc/snippets/warning.c
     #include <fpnglib/debug.h>
     
     int main(void)
     {
       double a = 1.0;
       FPNGL_WARNING("This will be displayed in debug/info mode: %g\n",a);
     }

7.2 Adding new IRNGs
====================

 -- Library Function: fpngl_irng32_t* fpngl_irng32_new (uint32_t SEED,
     const char* NAME, uint32_t MIN, uint32_t MAX, void* STATE, void*
     (*COPY_STATE)(void*), uint32_t (*NEXT32)(void*), uint64_t
     (*NEXT64)(void*), uint32_t (*NEXTK)(void*, uint32_t), void
     (*NEXT_ARRAY32)(void *, uint32_t *, uint32_t), void
     (*NEXT_ARRAY64)(void *, uint64_t *, uint32_t), void
     (*DELETE)(void*))

7.3 Miscellaneous Supporting Code
=================================


File: fpnglib.info,  Node: Function Index,  Next: Type Index,  Prev: Extending the Library

8 Function Index
****************

 [index ]
* Menu:

* fpngl_class_float64_new:               Drawing floats non-uniformly.
                                                              (line  16)
* FPNGL_DEBUG:                           Extending the Library.
                                                              (line  24)
* fpngl_distance_float64:                IEEE 754 and the Floating-Point Unit.
                                                              (line 293)
* fpngl_distribution_delete:             Non-Uniform Distributions.
                                                              (line  72)
* fpngl_distribution_new:                Non-Uniform Distributions.
                                                              (line  55)
* fpngl_distribution_next32:             Non-Uniform Distributions.
                                                              (line  78)
* fpngl_div32:                           Double Precision FRNGs.
                                                              (line  24)
* fpngl_div53:                           Double Precision FRNGs.
                                                              (line  18)
* fpngl_drand48bsd:                      Double Precision FRNGs.
                                                              (line  10)
* fpngl_drand48gnu:                      Double Precision FRNGs.
                                                              (line  30)
* fpngl_drand48_lcg64:                   Integer RNGs available.
                                                              (line  95)
* fpngl_float64:                         Drawing floats in a class.
                                                              (line  27)
* fpngl_float64_distrib:                 Drawing floats non-uniformly.
                                                              (line  30)
* fpngl_fog05:                           Double Precision FRNGs.
                                                              (line  42)
* fpngl_fog97:                           Double Precision FRNGs.
                                                              (line  35)
* fpngl_fprng32_name:                    Floating-Point Random Generators.
                                                              (line  57)
* fpngl_fprng32_seed:                    Floating-Point Random Generators.
                                                              (line  64)
* fpngl_fprng64_name:                    Floating-Point Random Generators.
                                                              (line  59)
* fpngl_fprng64_seed:                    Floating-Point Random Generators.
                                                              (line  66)
* fpngl_frng32_delete:                   Floating-Point Random Generators.
                                                              (line  18)
* fpngl_frng32_max:                      Floating-Point Random Generators.
                                                              (line  25)
* fpngl_frng32_min:                      Floating-Point Random Generators.
                                                              (line  24)
* fpngl_frng32_nextf32:                  Floating-Point Random Generators.
                                                              (line  38)
* fpngl_frng32_next_arrayf32:            Floating-Point Random Generators.
                                                              (line  47)
* fpngl_frng64_delete:                   Floating-Point Random Generators.
                                                              (line  19)
* fpngl_frng64_max:                      Floating-Point Random Generators.
                                                              (line  27)
* fpngl_frng64_min:                      Floating-Point Random Generators.
                                                              (line  26)
* fpngl_frng64_nextf64:                  Floating-Point Random Generators.
                                                              (line  40)
* fpngl_frng64_next_arrayf64:            Floating-Point Random Generators.
                                                              (line  49)
* fpngl_gnuc_lcg64:                      Integer RNGs available.
                                                              (line  83)
* fpngl_golang:                          Double Precision FRNGs.
                                                              (line  46)
* fpngl_inf64:                           Drawing floats in a class.
                                                              (line  14)
* fpngl_irng32_array32:                  Integer Random Generators.
                                                              (line  76)
* fpngl_irng32_array64:                  Integer Random Generators.
                                                              (line  92)
* fpngl_irng32_delete:                   Integer Random Generators.
                                                              (line  33)
* fpngl_irng32_max:                      Integer Random Generators.
                                                              (line 133)
* fpngl_irng32_min:                      Integer Random Generators.
                                                              (line 126)
* fpngl_irng32_name:                     Integer Random Generators.
                                                              (line 117)
* fpngl_irng32_new:                      Extending the Library.
                                                              (line  60)
* fpngl_irng32_next32:                   Integer Random Generators.
                                                              (line  40)
* fpngl_irng32_next64:                   Integer Random Generators.
                                                              (line  50)
* fpngl_irng32_nextk:                    Integer Random Generators.
                                                              (line  60)
* fpngl_irng32_seed:                     Integer Random Generators.
                                                              (line 107)
* fpngl_irng32_seed <1>:                 Integer Random Generators.
                                                              (line 111)
* fpngl_irng64_array32:                  Integer Random Generators.
                                                              (line  78)
* fpngl_irng64_array64:                  Integer Random Generators.
                                                              (line  94)
* fpngl_irng64_delete:                   Integer Random Generators.
                                                              (line  34)
* fpngl_irng64_max:                      Integer Random Generators.
                                                              (line 135)
* fpngl_irng64_min:                      Integer Random Generators.
                                                              (line 128)
* fpngl_irng64_name:                     Integer Random Generators.
                                                              (line 119)
* fpngl_irng64_next32:                   Integer Random Generators.
                                                              (line  42)
* fpngl_irng64_next64:                   Integer Random Generators.
                                                              (line  52)
* fpngl_irng64_nextk:                    Integer Random Generators.
                                                              (line  62)
* fpngl_irng64_seed:                     Integer Random Generators.
                                                              (line 109)
* fpngl_irng_array32:                    Integer Random Generators.
                                                              (line  80)
* fpngl_irng_array64:                    Integer Random Generators.
                                                              (line  96)
* fpngl_irng_delete:                     Integer Random Generators.
                                                              (line  35)
* fpngl_irng_max:                        Integer Random Generators.
                                                              (line 137)
* fpngl_irng_min:                        Integer Random Generators.
                                                              (line 130)
* fpngl_irng_name:                       Integer Random Generators.
                                                              (line 121)
* fpngl_irng_new32:                      Unsized RNGs.        (line  47)
* fpngl_irng_new64:                      Unsized RNGs.        (line  49)
* fpngl_irng_next:                       Unsized RNGs.        (line  60)
* fpngl_irng_next32:                     Integer Random Generators.
                                                              (line  44)
* fpngl_irng_next64:                     Integer Random Generators.
                                                              (line  54)
* fpngl_irng_nextk:                      Integer Random Generators.
                                                              (line  64)
* fpngl_is_irng32:                       Integer Random Generators.
                                                              (line 140)
* fpngl_is_irng64:                       Integer Random Generators.
                                                              (line 141)
* fpngl_java:                            Double Precision FRNGs.
                                                              (line  50)
* fpngl_KGW:                             Double Precision FRNGs.
                                                              (line  53)
* fpngl_lecuyer_simard:                  Double Precision FRNGs.
                                                              (line  57)
* fpngl_matlabp5:                        Double Precision FRNGs.
                                                              (line   6)
* fpngl_minstd64:                        Integer RNGs available.
                                                              (line  76)
* fpngl_mt19937v32:                      Integer RNGs available.
                                                              (line  55)
* fpngl_mt19937v32_by_array:             Integer RNGs available.
                                                              (line  57)
* fpngl_mt19937v64:                      Integer RNGs available.
                                                              (line 104)
* fpngl_mt19937v64_by_array:             Integer RNGs available.
                                                              (line 106)
* fpngl_mupad:                           Double Precision FRNGs.
                                                              (line  14)
* fpngl_mupad_lcg64:                     Integer RNGs available.
                                                              (line 100)
* fpngl_nan64:                           Drawing floats in a class.
                                                              (line  23)
* fpngl_nextafter64:                     IEEE 754 and the Floating-Point Unit.
                                                              (line 239)
* fpngl_normal64:                        Drawing floats in a class.
                                                              (line  18)
* fpngl_previous64:                      IEEE 754 and the Floating-Point Unit.
                                                              (line 266)
* fpngl_randu64:                         Integer RNGs available.
                                                              (line  89)
* fpngl_range32:                         Random Integers in a Range.
                                                              (line  49)
* fpngl_range64:                         Random Integers in a Range.
                                                              (line  51)
* fpngl_rationalLCG10:                   Double Precision FRNGs.
                                                              (line  61)
* fpngl_signed_distance_float64:         IEEE 754 and the Floating-Point Unit.
                                                              (line 301)
* fpngl_subnormal64:                     Drawing floats in a class.
                                                              (line   6)
* fpngl_ubound32:                        Random Integers in a Range.
                                                              (line  23)
* fpngl_ubound64:                        Random Integers in a Range.
                                                              (line  25)
* fpngl_von_neumann_metropolis:          Integer RNGs available.
                                                              (line  41)
* FPNGL_WARNING:                         Extending the Library.
                                                              (line  40)
* fpngl_xor4096iv32:                     Integer RNGs available.
                                                              (line  68)
* fpngl_xor4096iv64:                     Integer RNGs available.
                                                              (line 117)
* fpngl_xor4096rv32:                     Single Precision FRNGs.
                                                              (line   6)
* fpngl_xor4096rv64:                     Double Precision FRNGs.
                                                              (line  65)
* fpngl_zero64:                          Drawing floats in a class.
                                                              (line  10)


File: fpnglib.info,  Node: Type Index,  Next: Concept Index,  Prev: Function Index

9 Type Index
************

 [index ]
* Menu:

* fpngl_frng32_t:                        General Organization of the Library.
                                                               (line 28)
* fpngl_frng64_t:                        General Organization of the Library.
                                                               (line 30)
* fpngl_irng32_t:                        Generating Random Integers.
                                                               (line 58)
* fpngl_irng32_t <1>:                    General Organization of the Library.
                                                               (line 22)
* fpngl_irng64_t:                        General Organization of the Library.
                                                               (line 23)
* fpngl_irng_t:                          General Organization of the Library.
                                                               (line 25)


File: fpnglib.info,  Node: Concept Index,  Prev: Type Index

10 Concept Index
****************

 [index ]
* Menu:

* _internal suffix:                      Extending the Library.
                                                               (line 13)
* Bug report:                            What is FPNGlib?.     (line 60)
* Compiling with libfpnglib.so:          Generating Random Integers.
                                                               (line 29)
* Cryptographic use:                     What is FPNGlib?.     (line 53)
* Global state:                          General Organization of the Library.
                                                               (line 38)
* Prefix:                                General Organization of the Library.
                                                               (line  8)
* Supported platforms:                   What is FPNGlib?.     (line 19)
* Type name formation:                   General Organization of the Library.
                                                               (line 19)



Tag Table:
Node: What is FPNGlib?75
Ref: What is FPNGlib?-Footnote-12874
Node: Getting Started with FPNGlib2976
Node: An Introduction to FPNGlib6185
Node: Generating Random Integers6954
Ref: Generating Random Integers-Footnote-110196
Node: Generating Random Integers in a Domain10464
Ref: biased_dice_c11199
Ref: Generating Random Integers in a Domain-Footnote-113532
Ref: Generating Random Integers in a Domain-Footnote-213605
Ref: Generating Random Integers in a Domain-Footnote-313737
Node: Generating Random Floating-Point Numbers13831
Ref: exa:mcpi18832
Ref: Generating Random Floating-Point Numbers-Footnote-120031
Ref: Generating Random Floating-Point Numbers-Footnote-220133
Ref: Generating Random Floating-Point Numbers-Footnote-320183
Node: Generating a random float with some properties20331
Ref: Generating a random float with some properties-Footnote-125223
Node: General Organization of the Library25357
Node: Integer Random Generators27370
Node: Unsized RNGs34340
Ref: exa:irng35091
Node: Integer RNGs available36847
Ref: tab:irngs37770
Node: Random Integers in a Range42279
Node: Non-Uniform Distributions45081
Ref: fig:biased_dice45656
Ref: exa:biased245730
Ref: Non-Uniform Distributions-Footnote-148564
Node: Floating-Point Random Generators48900
Ref: Floating-Point Random Generators-Footnote-152309
Node: Existing float RNGs52560
Node: Single Precision FRNGs52796
Node: Double Precision FRNGs53059
Node: Drawing floats in a class55466
Ref: Drawing floats in a class-Footnote-158330
Ref: Drawing floats in a class-Footnote-258441
Node: Drawing floats non-uniformly58551
Node: IEEE 754 and the Floating-Point Unit60372
Node: Extending the Library70521
Ref: fig:classes70780
Node: Function Index72789
Node: Type Index86613
Node: Concept Index87645

End Tag Table
