This is fpnglib.info, produced by makeinfo version 6.5 from
fpnglib.texi.

1 What is FPNGlib?
******************

FPNGlib is a C library that offers pseudo-random generators in a unified
framework.  As the name implies, its strong point is the availability of
many IEEE 754(1) floating-point random number generators, with the
possibility to control the kind of floating-point number generated
(e.g., the amount of subnormal vs.  normal) and their properties (e.g.,
probability of having a least significant bit of the fractional part to
be 1)

   Even though it is entirely written in ISO Standard C99, FPNGlib is,
at present, only supported on UNIX-like systems (GNU/Linux and Mac OS X
are the only two tested environments) due to the tools used for its
configuration, compilation and deployment (_autotools_).

   More information about the FPNGlib library can be found at the
project homepage, <https://gitlab.univ-nantes.fr/goualard-f/fpnglib>.

   This manual assumes a basic knowledge of the IEEE~754 standard and
refers to the internal representation of floating-point numbers in
several places.  Readers unfamiliar with it may find beneficial to at
least read the Wikipedia entry (https://en.wikipedia.org/wiki/IEEE_754)
for the standard first.

   The FPNGlib library contains code from third parties, specifically:
   * xorgens 3.06 (https://maths-people.anu.edu.au/~brent/random.html)
     by Richard Brent, licenced under the GNU General Public License
     (http://www.gnu.org/copyleft/gpl.html);
   * Both 64 bits and 32 bits versions of the Mersenne twister
     (http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html), by
     Takuji Nishimura and Makoto Matsumoto, whose licenses can be found
     in files 'src/mt19937-64.c' and 'src/mt19937ar.c'.

   Additionally, the implementation of the Walker/Vose algorithm in
'src/walker_vose.c' is mostly a reimplementation in C of the Java
version by Keith Schwarz
(<https://www.keithschwarz.com/interesting/code/?dir=alias-method>).
Some code is also directly taken from the GNU GSL 2.6
(https://www.gnu.org/software/gsl/) implementation of the same.

A Word of Caution
=================

FPNGlib does not contain any true random generator as its focus is on
reproducibility for applications such as Monte-Carlo algorithms and the
like.  As a consequence, it shall not be used for cryptographic
applications.

Reporting a Bug
===============

Questions and bug reports shall be directly submitted on the GitLab
platform (https://gitlab.univ-nantes.fr/goualard-f/fpnglib/issues) for
the project.

2 Getting Started with FPNGlib
******************************

This chapter describes the very first steps with FPNGlib, from the
retrieval of the archive for the library to the first program you will
write to test its potential.  If you are accustomed to work with
autotools-based software, feel free to proceed directly to *note An
Introduction to FPNGlib::.

2.1 Installation
================

The FPNGlib library uses the _autotools_ (autoconf
(https://www.gnu.org/software/autoconf/), automake
(https://www.gnu.org/software/automake/), libtool
(https://www.gnu.org/software/libtool/)) for configuration, compilation,
and deployment.  However, these tools do not need to be present on your
computer as long as you do not modify the configuration files
('configure.ac' and the various 'Makefile.am' files).

   The library is entirely written in the ISO/IEC 9899:1999 C language.
Therefore, its compilation requires a sufficiently recent C compiler
such as any GNU C Compiler v. 4.5 or higher.

   In order to test the library, you will need to install 'check' v.
0.11.0 or higher (<https://libcheck.github.io/check/>) beforehand.  If
your compiler does not support the macro '__VA_OPT__', some tests will
not be performed.  That macro should be available in GCC version 8 and
above, and in Clang version 6 and above.

   Before compiling the library, you need to configure it.  It is done
by calling the command './configure' in the root directory of FPNGlib.
The command accepts many options, among them:

     '--help': displays a list of all the options available;
     '--prefix=<PATH TO INSTALL INTO>': gives the path to install the
     code into.  The header files will go into an 'include/'
     subdirectory, while the library will go into a 'lib/' subdirectory;
     '--enable-debug=[YES/INFO/PROFILE/NO]': define whether the code
     should be compiled with debugging information and assertion
     support.  The default is 'yes'.
   There are many other options, shared by all autotools-based
applications.  Use './configure --help' to get the complete list.

   Once the configuration is complete, you may call 'make' in the root
directory of the distribution for FPNGlib to compile the library.

   After having compiled the library, you should test it, in order to
ensure that everything is ok.  This is done by calling 'make check'.  If
no error is detected, you may proceed to the installation phase.

   The library should be installed before being used.  However, if you
want to get a taste of it beforehand, you may modify and execute the
examples in the sub-directory 'examples/', even before the installation.
Calling 'make' in this directory will recompile the necessary files.

   The installation is done by calling 'make install' from the top
directory of the distribution.  By default, the library is installed
into '/usr/local'.


File: fpnglib.info,  Node: An Introduction to FPNGlib

2.2 An Introduction to FPNGlib
==============================

FPNGlib offers generators for random integers and random IEEE 754
floating-point numbers.  We will first see how to obtain random integers
in *note Generating Random Integers:: and *note Generating Random
Integers in a Domain::, and then random floats in *note Generating
Random Floating-Point Numbers:: and *note Generating a random float with
some properties::.

* Menu:

* Generating Random Integers::
* Generating Random Integers in a Domain::
* Generating Random Floating-Point Numbers::
* Generating a random float with some properties::

   ---------- Footnotes ----------

   (1) IEEE Standard for Floating-Point Arithmetic.  IEEE STD 754-2008.
IEEE Computer Society, 2008.


File: fpnglib.info,  Node: Generating Random Integers,  Next: Generating Random Integers in a Domain,  Up: An Introduction to FPNGlib

2.2.1 Generating Random Integers
--------------------------------

Our very first program using FPNGlib simply draws one integer at random:

// doc/snippets/isimple.c
#include <stdio.h>
#include <fpnglib/mt19937ar.h>

const uint32_t seed = 13;

int main(void)
{
  fpngl_irng32_t *irng32 = fpngl_mt19937v32(seed);
  printf("%u\n",fpngl_irng32_next32(irng32));
  printf("%lu\n",fpngl_irng32_next64(irng32));
  fpngl_irng32_delete(irng32);
}

   Assuming you have installed FPNGlib locally in some directory
'$HOME/local' by configuring it with the command './configure
--prefix=$HOME/local', you may compile the example above by calling
'gcc' as such:

     gcc -I$HOME/local/include -L$HOME/local/lib \
           -o simple simple.c -lfpnglib

   Of course, if both the _include_ directory and the _lib_ directory
paths appear in the relevant environment variables ('C_INCLUDE_PATH' and
'LD_LIBRARY_PATH', respectively), you may dispense with the '-I' and
'-L' directives entirely.  Alternatively, as long as you work on the
example file provided in the distribution of the library, you may simply
call 'make isimple' to compile it.

   The output of this program should be:
3340206418
11203470090111516746

   In the example above, we use the 32 bits version of the Mersenne
Twister MT19937(1), but FPNGlib also offers the 64 bits version,
declared in 'fpnglib/mt19937-64.h'.

   Random integers come in two sizes: 32 bits and 64 bits.  As
exemplified in the example above, both sizes may be created by 32 bits
generators as well as 64 bits ones: A 32 bits generator will combine two
outputs to return a 64 bits integer; on the other hand, a 64 bits
generator will usually split its output into two 32 bits integers and
return one of them to produce a 32 bits integer.

   All Random Number Generators ("RNG") may be initialized by a single
integer, the _seed_.  In addition, some may be initialized by other
means, mostly vectors of integers.  It is the case with the Mersenne
Twister MT19937, of which an instance may be created with the
'fpngl_mt19937v32_by_array' function instead of 'fpngl_mt19937v32'.
Both functions return a pointer to an object of the opaque type
'fpngl_irng32_t'.  Since the implementation of that type is not public,
all object of the type must be manipulated through pointers only.  This
is the rule for most types in FPNGlib.

   By calling the function 'fpngl_irng32_next32', we compute the next 32
bits integer.  When calling the function 'fpngl_irng32_next64', the next
two 32 bits integer are computed and combined to produce one 64 bits
integer.

   The call to 'fpngl_mt19937v32' allocates some memory from the heap to
represent the internal structure of the MT19937 RNG. We need to call
'fpngl_irng32_delete' to reclaim that memory as soon as the RNG is no
longer used.

   ---------- Footnotes ----------

   (1) 'Mersenne Twister: A 623-dimensionally equidistributed uniform
pseudorandom number generator, M. Matsumoto and T. Nishimura. ACM Trans.
on Modeling and Computer Simulation, 8(1), 1998.'
(http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/earticles.html)


File: fpnglib.info,  Node: Generating Random Integers in a Domain,  Next: Generating Random Floating-Point Numbers,  Prev: Generating Random Integers,  Up: An Introduction to FPNGlib

2.2.2 Generating Random Integers in a Domain
--------------------------------------------

A 32 bits Integer RNG ("IRNG", for short) will usually draw an integer
in the domain [0,2^{32}-1] or in some other smaller but still
impractically large domain.  More often than not, simulations require
drawing integers in some precise domain, say [1,6] to simulate a dice,
for example.  For such an application, many sources still suggest to
draw an integer in the full domain of the RNG and then use the modulo to
restrict the output to the correct domain:
// doc/snippets/biased_dice.c
#include <stdio.h>
#include <fpnglib/mt19937ar.h>

const uint32_t seed = 13;

int main(void)
{
  fpngl_irng32_t *irng32 = fpngl_mt19937v32(seed);
  printf("%u\n",(fpngl_irng32_next32(irng32) % 6) + 1);
  fpngl_irng32_delete(irng32);
}

   However, since 2^{32} = 6\times 715827882 + 4, there are 715827883
ways to produce the numbers 1 to 4, and only 715827882 ways to produce
the numbers 5 and 6, which introduces a 1.397\times 10^{-7}% bias.  A
very small bias indeed, but one that could become significant if one
used a different RNG, such as a _Linear Congruential Generator_(1)
("LCG") with a congruence much smaller than 2^{32}.

   With FPNGLlib, the proper way to generate a random integer in the
domain [0,k], is to use the 'fpngl_ubound32' or 'fpngl_ubound64'
functions available in 'fpnglib/irange.h', depending on the type of RNG
used:

// doc/snippets/dice.c
#include <stdio.h>
#include <fpnglib/mt19937ar.h>
#include <fpnglib/irng_t.h>
#include <fpnglib/irange.h>

const uint32_t seed = 13;

int main(void)
{
  fpngl_irng_t *irng = fpngl_irng_new32(fpngl_mt19937v32(seed));
  printf("%u\n",fpngl_ubound32(irng,6) + 1);
  fpngl_irng_delete(irng);
}
   Remember that the function 'fpngl_mt19937v32' creates a 32 bits RNG
with type 'fpngl_irng32_t'.  The 'fpngl_ubound32' function computes a
random integer in [0,k-1], given k as its second argument.  However, it
must accept to do so with both a 32 bits RNG and a 64 bits RNG. We
therefore need to encapsulate the actual 32 bits RNG into a "generic"
RNG of type 'fpngl_irng_t' with the function 'fpngl_irng_new32'.  The
'irng' variable owns the 32 bits RNG it encapsulates and is responsible
for its deletion, which will be done when we call 'fpngl_irng_delete'
instead of 'fpngl_irng32_delete'.

   The 'fpngl_ubound32' function uses the modification by O'Neill(2) of
Lemire's algorithm(3) to draw integers in an interval.  The
'fpngl_ubound64' uses the same algorithm, provided a 128 bits integer
type is available on the platform used.  Otherwise, it uses slower
methods presented by O'Neill at
<https://www.pcg-random.org/posts/bounded-rands.html>.

   To draw integers from a domain [a,b] instead of [0,k], one can use
the functions 'fpngl_range32' and 'fpngl_range64'.

   ---------- Footnotes ----------

   (1) '<https://en.wikipedia.org/wiki/Linear_congruential_generator>'.

   (2) Efficiently Generating a Number in a Range, Melissa E. O'Neil,
<https://www.pcg-random.org/posts/bounded-rands.html>, 2018.

   (3) Fast Random Integer Generation in an Interval, Daniel Lemire, ACM
TOMACS 29(1), 2019.


File: fpnglib.info,  Node: Generating Random Floating-Point Numbers,  Next: Generating a random float with some properties,  Prev: Generating Random Integers in a Domain,  Up: An Introduction to FPNGlib

2.2.3 Generating Random Floating-Point Numbers
----------------------------------------------

One of the strong points of FPNGlib is the generation of IEEE 754
floating-point numbers(1) ("floats", for short).  It offers many methods
to draw floats in different domains and with various properties.

   In the following example, we use the same RNG as the one used for
'java.util.Random' in Java 8 to compute one double precision
floating-point number in [0,1):

// doc/snippets/fsimple.c
#include <stdio.h>
#include <fpnglib/frng64_java.h>

const uint32_t seed = 13;

int main(void)
{
  fpngl_frng64_t *frng64 = fpngl_java(seed);
  printf("%a\n",fpngl_frng64_nextf64(frng64));
  fpngl_frng64_delete(frng64);
}

   The output expressed using the C99 hexadecimal format(2) is
"'0x1.314880e9bdp-10'."

   Floating-point number generators ("FRNG"s, for short) are either of
the type 'fpngl_frng32_t' when they produce single precision floats, or
'fpngl_frng64_t' for double precision.  In the same way as for integer
generators, floats generators can only be manipulated through pointers
to objects of these types.  All generators of either type must implement
the same functionalities.  In particular, as shown in *note Example 2.1:
exa:mcpi, double precision generators must implement the following
calls:
   * 'fpgnl_frng64_name()': returns a constant string corresponding to
     the name of the generator;
   * 'fpngl_fnrg64_nextf64()': returns the next double precision random
     number;
   * 'fpngl_frng64_delete()': reclaims the memory used to represent the
     generator.
   As a consequence, it is possible to write functions requiring random
floats independently of the FRNG actually used, and to pass it as a
parameter (see, e.g., 'mcpi' in *note Example 2.1: exa:mcpi.).

   Note, however, that FRNGs are not bound to return floats in any
prescribed domain: some may return values in "[0,1)," some in "(0,1),"
and some others in any other domain.  It is then the responsibility of
the programmer to choose FRNGs according to the domains they are
interested into.

   A classical way to implement FRNGs is to rely on an integer RNG and
divide its output by some integer constant, usually the largest possible
integer the RNG can produce or the next integer above.  This is what we
do to create 'frng0' in *note Example 2.1: exa:mcpi.  Firstly, we create
an IRNG based on the 32 bits version of the Mersenne Twister MT19937,
then we create an FRNG by using the 'fpngl_bydivision_new' constructor.
That constructor takes three parameters:
  1. A name for the newly created FRNG ("'FMT19937v32'," in *note
     Example 2.1: exa:mcpi.);
  2. An IRNG of the type 'fpngl_irng_t';
  3. A divisor by which each random integer should be divided (here, we
     choose to divide by the smallest integer strictly larger than the
     largest random number that our IRNG can produce, therefore creating
     a FRNG returning values in [0,1)(3)).

   Note that, as is always the case in FPNGlib, the FRNG 'frng0' created
from the IRNG 'irng32' "owns" it and is, therefore, responsible for its
destruction.  This is why we do not call 'fpngl_irng_delete' at the end
of the program: the call 'fpngl_frng64_delete(frng0)' is sufficient to
reclaim both the memory allocated to represent 'frng0' and 'irng32'.

   The FRNG created with 'fpngl_drand48bsd' also relies on the division
of the result of a Linear Congruential Generator by a constant integer.
The result is a floating-point number in [0,1) with 48 bits of entropy
only.

// doc/snippets/mcpi.c
#include <stdio.h>
#include <math.h>
#include <fpnglib/frng64_division.h>
#include <fpnglib/mt19937ar.h>
#include <fpnglib/irng_t.h>

#define NITERS 10000000
const uint64_t seed = 13;
const double m_pi = 0x1.921fb54442d18p+1;

// Estimating the value of pi by throwing darts at a unit circle.
double mcpi(fpngl_frng64_t *frng, uint32_t niters)
{
  uint32_t in_circle = 0;
  for (uint32_t i = 0; i < niters; ++i) {
    double x = fpngl_frng64_nextf64(frng);
    double y = fpngl_frng64_nextf64(frng);
    in_circle += ((x*x + y*y) <= 1);
  }
  return 4*((double)in_circle / niters);
}

int main(void)
{
  fpngl_irng_t *irng32 = fpngl_irng_new32(fpngl_mt19937v32(seed));
  fpngl_frng64_t *frng0 = fpngl_bydivision_new("FMT19937v32",irng32,
                                               fpngl_irng_max(irng32)+1);
  fpngl_frng64_t *frng1 = fpngl_drand48bsd(seed);
  printf("%s: %.16g\n",fpngl_frng64_name(frng0), mcpi(frng0,NITERS));
  printf("%s: %.16g\n",fpngl_frng64_name(frng1), mcpi(frng1,NITERS));
  fpngl_frng64_delete(frng0);
  fpngl_frng64_delete(frng1);
}

Example 2.1: Computing an approximation to \pi with a Monte Carlo
method.

   ---------- Footnotes ----------

   (1) IEEE Standard for Floating-Point Arithmetic.  IEEE STD 754-2008.
IEEE Computer Society, 2008.

   (2) See Section 6.4.4.2 of ISO/IEC 9899:1999.

   (3) As a side note, the open bound is guaranteed only if the divisor
is smaller than 2^{53}, which is the case here since we use a 32 bits
IRNG.


File: fpnglib.info,  Node: Generating a random float with some properties,  Prev: Generating Random Floating-Point Numbers,  Up: An Introduction to FPNGlib

2.2.4 Generating a random float with some properties
----------------------------------------------------

For some applications, we are interested in drawing floating-point
numbers with some definite properties only.  That might be:
   * Only subnormal floats;
   * Only normal floats;
   * Subnormal and normal floats in some precision proportion;
   * Only positive floats with the exponent in some domain and the
     fractional part in another domain;
   * ...

   FPNGlib is particularly well suited for this kind of applications as
it offers many ways to define the properties the floats drawn should
meet.

   For example, if only random double precision subnormal floats are
required, one can use the 'fpngl_denormal64' function.  For random
normal floats, the 'fpngl_normal64' function can be used:

// doc/snippets/subnormal.c
#include <stdio.h>
#include <fpnglib/float64.h>
#include <fpnglib/mt19937-64.h>

const uint64_t seed = 42;

int main(void)
{
  fpngl_irng_t *irng = fpngl_irng_new64(fpngl_mt19937v64(seed));
  printf("Random denormal: %g\n",fpngl_denormal64(irng));
  printf("Random normal: %g\n",fpngl_normal64(irng));
  fpngl_irng_delete(irng);
}

   Both functions require an integer RNG, as the subnormal and normal
random floats are constructed from their exponent and fractional part
fields.

   FPNGlib considers five classes of floats:
   * \pm0;
   * Subnormal;
   * Normal;
   * \pm\infty;
   * _Not a Number_.
   There are generator functions for each of theses classes.  In
addition, using the 'fpngl_class_float64_new' function, it is easy to
draw floats from these five classes with different probabilities
attached to each:
// doc/snippets/distrib.c
#include <stdio.h>
#include <fpnglib/float64.h>
#include <fpnglib/mt19937-64.h>

const uint64_t seed = 42;

int main(void)
{
  fpngl_irng_t *irng = fpngl_irng_new64(fpngl_mt19937v64(seed));
  fpngl_distribution_t *dist = fpngl_class_float64_new(irng,
                                   (double[]){0.125,0.25,0.5,0.125,0.0});
  for (uint32_t i = 0; i < 10; ++i) {
    printf("%g\n",fpngl_float64_distrib(dist));
  }
  fpngl_irng_delete(irng);
}
   This program displays 10 floats, with probabilities 12.5% that they
are equal to \pm0, 25% that they are subnormal, 50% that they are
normal, and 12.5% that they are infinite.

   A more flexible way to draw floats from a specific set is to put
constraints on the acceptable sign, exponent and fractional part with
the 'fpngl_float64' function.  The following program, for example, will
draw 10 double precision floats in '[2,4)':
// doc/snippets/float64.c
#include <stdio.h>
#include <fpnglib/constants64.h>
#include <fpnglib/float64.h>
#include <fpnglib/mt19937-64.h>

const uint64_t seed = 13;

int main(void)
{
  fpngl_irng_t *irng = fpngl_irng_new64(fpngl_mt19937v64(seed));
  for (uint32_t i = 0; i < 10; ++i) {
    printf("%g\n",fpngl_float64(irng, fpngl_positive, 1024, 1024,
                                fpngl_minfrac64, fpngl_maxfrac64,
                                fpngl_noand64, fpngl_noor64));
  }
  fpngl_irng_delete(irng);
}
   The first parameter of 'fpngl_float64' is an integer RNG, which is
used to draw the integers defining the sign, exponent and fractional
part of the float returned.  The second parameter indicates what is the
expected sign of the float drawn; It can be one of:
   * 'fpngl_positive' (for drawing only positive floats);
   * 'fpngl_negative' (for drawing only negative floats);
   * 'fpngl_whatever' (for either positive or negative floats, with an
     equiprobability of both).
   The third and fourth parameters establish bounds on the _biased_
exponent(1).  The fifth and sixth parameters establish bounds on the
possible values of the fractional part, with 'fpngl_minfrac64' being the
smallest possible value, equal to '0x0000000000000', and
'fpngl_maxfrac64' being the largest possible value, equal to
'0xfffffffffffff'.  Lastly, the seventh and eighth parameters are masks
that are ultimately applied to the fractional part: the seventh
parameter is "anded" with the fractional part and the eighth parameter
is "ored" with that resulting value.

   In the example above, we are asking for floats with a positive sign,
an exponent of '1' (1024 minus the bias of 1023) and a fractional part
between '0x0000000000000' and '0xfffffffffffff', that is --in binary--
floats from +1.0\times2^1 to
+1.111111111111111111111111111111111111111111111111111\times2^1, or --in
decimal--, from 2.0 to 4.0-2^{-51}.

3 General Organization of the Library
*************************************

In FPNGlib, all public constants, variables, types, and functions are
prefixed with 'fpngl_' to make them stand apart in larger programs and
avoid name collisions.  All header files from FPNGlib are in the
directory 'fpnglib/'.

   All RNGs have types whose name is formed according to the same
principle: first the prefix 'fpngl_', then the type of the RNG ('irng'
for an RNG generating integers, and 'frng' for an RNG generating
floating-point numbers) followed by the size of the values returned
('32' for 32 bits integers and single precision floating-point numbers,
and '64' for 64 bits integers and double precision floating-point
numbers), and finally the postfix '_t' to mark the name as a type.  A
slight exception to this scheme is the type 'fpngl_irng_t' that can wrap
32 bits as well as 64 bits integer RNGs.

   All in all, there are at present five Random Number Generator types
in FPNGlib:
   * 'fpngl_irng32_t'.  RNG generating 32 bits integers natively;
   * 'fpngl_irng64_t'.  RNG generating 64 bits integers natively;
   * 'fpngl_irng_t'.  Wrapper for a RNG generating natively either 32
     bits or 64 bits integers;
   * 'fpngl_frng32_t'.  RNG generating single precision ('float')
     IEEE 754 floating-point numbers;
   * 'fpngl_frng64_t'.  RNG generating double precision ('double')
     IEEE 754 floating-point numbers.
   Note that both 32 bits and 64 bits integer RNGs can generate 32 bits
as well as 64 bits integers with, respectively, the functions
'fpngl_irng32_next64' and 'fpngl_irn64_next32'.

   The complete state of all the RNGs is entirely contained in an object
of one of the abovementioned types.  There are no global variables,
which means that the user may define and use several RNGs, even of the
same type, without any risk of interferences between them.

   ---------- Footnotes ----------

   (1) The _biased_ exponent e for double precision floats takes its
value in [0,2047], the actual exponent E being equal to e-1023.


File: fpnglib.info,  Node: Integer Random Generators

4 Integer Random Generators
***************************

Random Number Generators that produce integers must all provide the same
services independently of the size of the integers they "natively"
produce:
   * Compute a 32 bits integer;
   * Compute a 64 bits integer;
   * Compute k random bits, with k being smaller than the size of the
     integers produced natively by the RNG;
   * Compute of an array of 32 bits integer;
   * Compute of an array of 64 bits integer;
   * Return the seed used to initialize the RNG;
   * Return the minimum integer the RNG can produce;
   * Return the maximum integer the RNG can produce.

   In addition, an RNG must possess a function to release the resources
acquired upon construction of an instance.  Each RNG type has its own
constructor (*Note Integer RNGs available::).

   In the following, we describe the functions providing these services
for RNGs of the type 'fpngl_irng32_t', 'fpngl_irng64_t', as well as for
the wrapper type 'fpngl_irng_t'.  The services specific to this last
type are described in *note Wrapping an IRNG::.

 -- Library Function: void fpngl_irng32_delete (fpngl_irng32_t* RNG)
 -- Library Function: void fpngl_irng64_delete (fpngl_irng64_t* RNG)
 -- Library Function: void fpngl_irng_delete (fpngl_irng_t* RNG)
     Releases the resources acquired upon the construction of the RNg
     RNG.

 -- Library Function: uint32_t fpngl_irng32_next32 (fpngl_irng32_t* RNG)
 -- Library Function: uint32_t fpngl_irng64_next32 (fpngl_irng64_t* RNG)
 -- Library Function: uint32_t fpngl_irng_next32 (fpngl_irng_t* RNG)
     Return the next 32 bits random integer.  A 64 bits RNG will usually
     compute a 64 bits integer and return the lower or higher 32 bits.

 -- Library Function: uint64_t fpngl_irng32_next64 (fpngl_irng32_t* RNG)
 -- Library Function: uint64_t fpngl_irng64_next64 (fpngl_irng64_t* RNG)
 -- Library Function: uint64_t fpngl_irng_next64 (fpngl_irng_t* RNG)
     Return the next 64 bits random integer.  A 32 bits RNG will be
     called twice to create a 64 bits integer.

 -- Library Function: uint32_t fpngl_irng32_nextk (fpngl_irng32_t* RNG,
          uint32_t K)
 -- Library Function: uint64_t fpngl_irng64_nextk (fpngl_irng64_t* RNG,
          uint32_t K)
 -- Library Function: uint64_t fpngl_irng_nextk (fpngl_irng_t* RNG,
          uint32_t K)
     Return the next K random bits.  The maximum value of K depends on
     the type of RNG:
        * K\in[0,32] for a 32 bits RNG;
        * K\in[0,64] for a 64 bits RNG;
        * K\in[0,64] for a wrapped RNG of type 'fpngl_irng_t'.

     Note that K may be greater than 32 for a 32 bits RNG when it is
     wrapped in an RNG of type 'fpngl_irng_t'.  In that case, the RNG is
     called twice and the two outputs are aggregated to form the result.

 -- Library Function: void fpngl_irng32_array32 (fpngl_irng32_t* RNG,
          uint32_t* T, uint32_t N)
 -- Library Function: void fpngl_irng64_array32 (fpngl_irng64_t* RNG,
          uint32_t* T, uint32_t N)
 -- Library Function: void fpngl_irng_array32 (fpngl_irng_t* RNG,
          uint32_t* T, uint32_t N)
     Fill the array T with N 32 bits random integers.  The array T must
     have been allocated to the correct size before the call.

     The speed-up obtained with this function, compared with calling N
     times a '*_next32' function depends on the RNG used.  For most
     implementations, a 64 bits RNG will be called at most N/2 times and
     each 64 bits integer split into two 32 bits integers to fill
     adjacent positions in the array.

 -- Library Function: void fpngl_irng32_array64 (fpngl_irng32_t* RNG,
          uint64_t* T, uint32_t N)
 -- Library Function: void fpngl_irng64_array64 (fpngl_irng64_t* RNG,
          uint64_t* T, uint32_t N)
 -- Library Function: void fpngl_irng_array64 (fpngl_irng_t* RNG,
          uint64_t* T, uint32_t N)
     Fill the array T with N 64 bits random integers.  The array T must
     have been allocated to the correct size before the call.

     The speed-up obtained with this function, compared with calling N
     times a '*_next64' function depends on the RNG used.  For most
     implementations, a 32 bits RNG will be called 2N times.

 -- Library Function: uint32_t fpngl_irng32_seed (fpngl_irng32_t* RNG)
 -- Library Function: uint64_t fpngl_irng64_seed (fpngl_irng64_t* RNG)
 -- Library Function: uint64_t fpngl_irng32_seed (fpngl_irng_t* RNG)
     Return the value used to initialize the RNG.

 -- Library Function: const char* fpngl_irng32_name (fpngl_irng32_t*
          RNG)
 -- Library Function: const char* fpngl_irng64_name (fpngl_irng64_t*
          RNG)
 -- Library Function: const char* fpngl_irng_name (fpngl_irng_t* RNG)
     Return a pointer to the string representing the name of the RNG.
     Refer to each constructor in *note Integer RNGs available:: to know
     the possible values.

 -- Library Function: uint32_t fpngl_irng32_min (fpngl_irng32_t* RNG)
 -- Library Function: uint64_t fpngl_irng64_min (fpngl_irng64_t* RNG)
 -- Library Function: uint64_t fpngl_irng_min (fpngl_irng_t* RNG)
     Return the smallest integer that can be drawn with the RNG.

 -- Library Function: uint32_t fpngl_irng32_max (fpngl_irng32_t* RNG)
 -- Library Function: uint64_t fpngl_irng64_max (fpngl_irng64_t* RNG)
 -- Library Function: uint64_t fpngl_irng_max (fpngl_irng_t* RNG)
     Return the largest integer that can be drawn with the RNG.

 -- Library Function: bool fpngl_is_irng32 (fpngl_irng_t* RNG)
 -- Library Function: bool fpngl_is_irng64 (fpngl_irng_t* RNG)
     Return 'true' if the wrapped RNG is, respectively, of the type
     'fpngl_irng32_t' or 'fpngl_irng64_t'.

* Menu:

* Wrapping an IRNG::
* Integer RNGs available::


File: fpnglib.info,  Node: Wrapping an IRNG,  Next: Integer RNGs available,  Up: Integer Random Generators

4.1 Wrapping an IRNG
====================

Since both 32 bits and 64 bits RNGs can produce 32 bits as well as 64
bits integers, users may be tempted to write programs that use an RNG,
irrespective of its type.  The 'fpngl_irng_t' type serves as a wrapper
around 32 bits and 64 bits RNGs to abstract their real limitations.  An
object of that type is constructed from an actual RNG of type
'fpngl_irng32_t' or 'fpngl_irng64_t' with, respectively, the functions
'fpngl_irng_new32' and 'fpngl_irng_new64':
// doc/snippets/irng.c
#include <stdio.h>
#include <fpnglib/irng_t.h>
#include <fpnglib/xorgens.h>

const uint32_t seed = 13;

void draw_twice(fpngl_irng_t *irng)
{
  printf("%lu\t%lu\n",fpngl_irng_next64(irng), fpngl_irng_next64(irng));
}

int main(void)
{
  fpngl_irng32_t *irng32 = fpngl_xor4096iv32(seed);
  fpngl_irng_t *irng = fpngl_irng_new32(irng32);
  draw_twice(irng);
  fpngl_irng_delete(irng);
  fpngl_irng64_t *irng64 = fpngl_xor4096iv64(seed);
  irng = fpngl_irng_new64(irng64);
  draw_twice(irng);
  fpngl_irng_delete(irng);
}
   Note that the new RNG constructed "owns" the RNG passed as a
parameter to 'fpngl_irng_new32' or 'fpngl_irng_new64' constructor, and
is responsible for its proper disposal.  The release of resources is
then done with 'fpngl_irng_delete' only.

 -- Library Function: fpngl_irng_t* fpngl_irng_new32 (fpngl_irng32_t
          *irng32)
 -- Library Function: fpngl_irng_t* fpngl_irng_new64 (fpngl_irng64_t
          *irng64)
     Wrap an 32 bits or 64 bits RNG into an 'fpngl_irng_t' object.  The
     new object is responsible for the destruction of the RNG passed as
     a parameter.  Consequently, IRNG32 (resp. IRNG64) should be never
     be deleted with 'fpngl_irng32_delete' (resp. 'fpngl_irng64_delete')
     afterwards.

   There is also a function to draw an integer of the size supported
natively by the wrapped RNG:

 -- Library Function: uint64_t fpngl_irng_next (fpngl_irng_t* RNG)
     This function is unique to the 'fpngl_irng_t' type.  If the wrapped
     RNG is of type 'fpngl_irng64_t', it behaves like
     'fpngl_irng_next64', otherwise it returns the integer computed with
     'fpngl_irng_next32' cast to 64 bits.


File: fpnglib.info,  Node: Integer RNGs available,  Prev: Wrapping an IRNG,  Up: Integer Random Generators

4.2 Integer RNGs available
==========================

5 Floating-Point Random Generators
**********************************

6 IEEE 754 and the Floating-Point Unit
**************************************

That chapter describes the various constants, functions and macros
provided by FPNGlib that do not directly contribute to the generation of
random numbers.

6.1 Constants
=============

Several constants related to the characteristics of the IEEE 754
floating-point format are defined in files 'fpnglib/constants32.h' --for
the single precision-- and 'fpnglib/constants64.h' --for the double
precision.

 -- Constant: uint32_t fpngl_emin32
 -- Constant: uint32_t fpngl_emin64
 -- Constant: uint32_t fpngl_emax32
 -- Constant: uint32_t fpngl_emax64
     Smallest and largest unbiased exponents for single and double
     precision float.  *Example*
     // doc/snippets/exponent.c
     #include <stdio.h>
     #include <math.h>
     #include <fpnglib/constants32.h>
     #include <fpnglib/constants64.h>
     
     int main(void)
     {
       printf("Single precision exponent in [%d, %d]\n",
              fpngl_emin32,fpngl_emax32);
       printf("Double precision exponent in [%d, %d]\n",
              fpngl_emin64,fpngl_emax64);
     }
     *Output:*
     Single precision exponent in [-126, 127]
     Double precision exponent in [-1022, 1023]

 -- Constant: uint32_t fpngl_t32
 -- Constant: uint32_t fpngl_t64
     Number of bits in the significand of a single or double precision
     float.  *Example:*
     // doc/snippets/significand.c
     #include <stdio.h>
     #include <math.h>
     #include <fpnglib/constants32.h>
     #include <fpnglib/constants64.h>
     
     int main(void)
     {
       printf("Number of digits with single precision: %u\n",
              (uint32_t)trunc(fpngl_t32*log10(2)));
       printf("Number of digits with double precision: %u\n",
              (uint32_t)trunc(fpngl_t64*log10(2)));
     }
     *Output:*
     Number of digits with single precision: 7
     Number of digits with double precision: 15

 -- Constant: float fpngl_mu32
 -- Constant: double fpngl_mu64
     Smallest positive float.  This is a subnormal number.  Example:
     // doc/snippets/mu.c
     #include <stdio.h>
     #include <math.h>
     #include <fpnglib/constants32.h>
     #include <fpnglib/constants64.h>
     
     int main(void)
     {
       printf("%d\n",nextafterf(0.0f,1.0f) == fpngl_mu32);
       printf("%d\n",nextafter(0.0,1.0) == fpngl_mu64);
     }
     Output:
     1
     1

 -- Constant: float fpngl_lambda32
 -- Constant: double fpngl_lambda64
     Smallest positive normal float.  Example:
     // doc/snippets/lambda.c
     #include <stdio.h>
     #include <fpnglib/constants32.h>
     #include <fpnglib/constants64.h>
     
     int main(void)
     {
       printf("Single precision smallest positive normal: %g\n",
              fpngl_lambda32);
       printf("Double precision smallest positive normal: %g\n",
              fpngl_lambda64);
     }
     Output:
     Single precision smallest positive normal: 1.17549e-38
     Double precision smallest positive normal: 2.22507e-308

 -- Constant: float fpngl_u32
 -- Constant: double fpngl_u64
     "Unit roundoff", which is half the distance between '1.0' and the
     next floating-point number.  Example:
     // doc/snippets/unitroundoff.c
     #include <stdio.h>
     #include <fpnglib/constants32.h>
     #include <fpnglib/constants64.h>
     
     int main(void)
     {
     	printf("Single precision unit roundoff: %g\n",fpngl_u32);
     	printf("Double precision unit roundoff: %g\n",fpngl_u64);
     }
     Output:
     Single precision unit roundoff: 5.96046e-08
     Double precision unit roundoff: 1.11022e-16

 -- Constant: float fpngl_max32
 -- Constant: double fpngl_max64
     Largest positive float smaller than the "infinity" value.  Example:
     // doc/snippets/max.c
     #include <stdio.h>
     #include <fpnglib/constants32.h>
     #include <fpnglib/constants64.h>
     
     int main(void)
     {
       printf("Single precision largest float: %g\n",fpngl_max32);
       printf("Double precision largest float: %g\n",fpngl_max64);
     }
     Output:
     Single precision largest float: 3.40282e+38
     Double precision largest float: 1.79769e+308

 -- Constant: float fpngl_NaN32
 -- Constant: double fpngl_NaN64
     Return a _Not a Number_.  Example:
     // doc/snippets/nan.c
     #include <stdio.h>
     #include <fpnglib/constants32.h>
     #include <fpnglib/constants64.h>
     
     int main(void)
     {
       printf("Single precision NaN: %g\n",fpngl_NaN32);
       printf("Double precision NaN: %g\n",fpngl_NaN64);
     }
     Output:
     Single precision NaN: nan
     Double precision NaN: nan

 -- Constant: float fpngl_infinity32
 -- Constant: double fpngl_infinity64
     Infinity value.  Example:
     // doc/snippets/inf.c
     #include <stdio.h>
     #include <fpnglib/constants32.h>
     #include <fpnglib/constants64.h>
     
     int main(void)
     {
       printf("Single precision infinity: %g\n",fpngl_infinity32);
       printf("Double precision infinity: %g\n",fpngl_infinity64);
     }
     Output:
     Single precision infinity: inf
     Double precision infinity: inf

 -- Constant: uint64_t fpngl_minfrac64
 -- Constant: uint64_t fpngl_maxfrac64
     Minimum and maximum value for the fractional part of a 64 bits
     double precision floating-point number.  These constants are mainly
     used when calling 'fpngl_float64' to draw floats with some
     properties.  Example:
     // doc/snippets/minmaxfrac64.c
     #include <stdio.h>
     #include <fpnglib/constants64.h>
     
     int main(void)
     {
       printf("minfrac64: %lx\n",fpngl_minfrac64);
       printf("maxfrac64: %lx\n",fpngl_maxfrac64);
     }
     Output:
     minfrac64: 0
     maxfrac64: fffffffffffff

 -- Constant: uint64_t fpngl_noand64
 -- Constant: uint64_t fpngl_noor64
     Masks to use with the function 'fpng_float64' when no _and_ mask
     (resp. no _or_ mask) is needed for the fractional part of the
     floats constructed.  Example:
     // doc/snippets/noandor.c
     #include <stdio.h>
     #include <fpnglib/constants64.h>
     
     int main(void)
     {
       printf("noand64 mask: %lx\n",fpngl_noand64);
       printf("noor64 mask: %lx\n",fpngl_noor64);
     }
     Output:
     noand64 mask: ffffffffffffffff
     noor64 mask: 0

6.2 Utility Functions
=====================

FPNGlib defines functions that can aid in computing the floating-point
numbers an application requires.  They are:

 -- Library Function: double fpngl_nextafter64 (double V, uint64_t N)
     Return a double precision number that is N floating-point numbers
     _after_ V on the real line.

     The value of N must be smaller or equal to '0xffe0000000000000'.
     The function will abort if N is greater than that and the library
     has been compiled with '--enable-debug=yes'.

     If V is an NaN, the function returns the same NaN. Otherwise, it
     returns either a finite float or a positive infinite, depending on
     the value of N and the distance of V to the maximum representable
     double precision float.

     Example:
     // doc/snippets/nextafter64.c
     #include <stdio.h>
     #include <fpnglib/constants64.h>
     #include <fpnglib/float64.h>
     
     int main(void)
     {
       printf("%d\n",fpngl_nextafter64(1.0, 1L<<52) == 2.0);
     }
     The output is '1' since there are 2^{52} floats from '1.0' to '2.0'
     in double precision.

 -- Library Function: double fpngl_previous64 (double V, uint64_t N)
     Return a double precision number that is N floating-point numbers
     _before_ V on the real line.

     The value of N must be smaller or equal to '0xffe0000000000000'.
     The function will abort if N is greater than that and the library
     has been compiled with '--enable-debug=yes'.

     If V is an NaN, the function returns the same NaN. Otherwise, it
     returns either a finite float or a positive infinite, depending on
     the value of N and the distance of V to the maximum representable
     double precision float.

     Example:
     // doc/snippets/previous64.c
     #include <stdio.h>
     #include <fpnglib/constants64.h>
     #include <fpnglib/float64.h>
     
     int main(void)
     {
       printf("%d\n",fpngl_previous64(fpngl_mu64, 2) == -fpngl_mu64);
     }
     The output is '1' since the smallest positive double precision
     float is separated from the largest negative float by '0'.

6.3 Manipulating the FPU
========================

7 Extending the Library
***********************

The library is written with an object-oriented style that should make it
easy to extend.

 [image src="fpnglib-figures/classes.jpg" text="" ]

figure 7.1: The "classes" of FPNGlib

7.1 Debugging facilities
========================

FPNGlib offers facilities to debug itself.  There are in particular some
macros that can be used to display messages to the standard error ouput
'stderr', provided the library was configured with the option
'--enable-debug=yes' (the default) or '--enable-debug=info' for some
macros.

 -- Macro: FPNGL_DEBUG (...)
     Uses 'fprintf' to output its arguments to 'stderr' if the macro
     'NDEBUG' is defined to '1'.  Otherwise, it does nothing.

     The macro flushes the output buffer with 'fflush' after each call.

     Example:
     // doc/snippets/debug.c
     #include <fpnglib/debug.h>
     
     int main(void)
     {
       double a = 1.0;
       FPNGL_DEBUG("This will be displayed only in debug mode: %g\n",a);
     }

 -- Macro: FPNGL_WARNING (...)
     Displays a warning message to 'stderr' if the library was
     configured with either '--enable-debug=yes' or
     '--enable-debug=info'.

     The macro flushes the output buffer with 'fflush' after each call.

     Example:
     // doc/snippets/warning.c
     #include <fpnglib/debug.h>
     
     int main(void)
     {
       double a = 1.0;
       FPNGL_WARNING("This will be displayed in debug/info mode: %g\n",a);
     }

8 Function Index
****************

 [index ]
* Menu:

* FPNGL_DEBUG:                           Integer RNGs available.
                                                              (line 291)
* fpngl_irng32_array32:                  Integer Random Generators.
                                                              (line  62)
* fpngl_irng32_array64:                  Integer Random Generators.
                                                              (line  77)
* fpngl_irng32_delete:                   Integer Random Generators.
                                                              (line  28)
* fpngl_irng32_max:                      Integer Random Generators.
                                                              (line 109)
* fpngl_irng32_min:                      Integer Random Generators.
                                                              (line 104)
* fpngl_irng32_name:                     Integer Random Generators.
                                                              (line  95)
* fpngl_irng32_next32:                   Integer Random Generators.
                                                              (line  34)
* fpngl_irng32_next64:                   Integer Random Generators.
                                                              (line  40)
* fpngl_irng32_nextk:                    Integer Random Generators.
                                                              (line  46)
* fpngl_irng32_seed:                     Integer Random Generators.
                                                              (line  90)
* fpngl_irng32_seed <1>:                 Integer Random Generators.
                                                              (line  92)
* fpngl_irng64_array32:                  Integer Random Generators.
                                                              (line  64)
* fpngl_irng64_array64:                  Integer Random Generators.
                                                              (line  79)
* fpngl_irng64_delete:                   Integer Random Generators.
                                                              (line  29)
* fpngl_irng64_max:                      Integer Random Generators.
                                                              (line 110)
* fpngl_irng64_min:                      Integer Random Generators.
                                                              (line 105)
* fpngl_irng64_name:                     Integer Random Generators.
                                                              (line  97)
* fpngl_irng64_next32:                   Integer Random Generators.
                                                              (line  35)
* fpngl_irng64_next64:                   Integer Random Generators.
                                                              (line  41)
* fpngl_irng64_nextk:                    Integer Random Generators.
                                                              (line  48)
* fpngl_irng64_seed:                     Integer Random Generators.
                                                              (line  91)
* fpngl_irng_array32:                    Integer Random Generators.
                                                              (line  66)
* fpngl_irng_array64:                    Integer Random Generators.
                                                              (line  81)
* fpngl_irng_delete:                     Integer Random Generators.
                                                              (line  30)
* fpngl_irng_max:                        Integer Random Generators.
                                                              (line 111)
* fpngl_irng_min:                        Integer Random Generators.
                                                              (line 106)
* fpngl_irng_name:                       Integer Random Generators.
                                                              (line  99)
* fpngl_irng_new32:                      Wrapping an IRNG.    (line  41)
* fpngl_irng_new64:                      Wrapping an IRNG.    (line  43)
* fpngl_irng_next:                       Wrapping an IRNG.    (line  54)
* fpngl_irng_next32:                     Integer Random Generators.
                                                              (line  36)
* fpngl_irng_next64:                     Integer Random Generators.
                                                              (line  42)
* fpngl_irng_nextk:                      Integer Random Generators.
                                                              (line  50)
* fpngl_is_irng32:                       Integer Random Generators.
                                                              (line 114)
* fpngl_is_irng64:                       Integer Random Generators.
                                                              (line 115)
* fpngl_nextafter64:                     Integer RNGs available.
                                                              (line 218)
* fpngl_previous64:                      Integer RNGs available.
                                                              (line 244)
* FPNGL_WARNING:                         Integer RNGs available.
                                                              (line 307)

9 Type Index
************

10 Concept Index
****************

 [index ]
* Menu:

* Bug report:                            (outside of any node).
                                                              (line   0)
* Compiling with libfpnglib.so:          Generating Random Integers.
                                                              (line  29)
* Cryptographic use:                     (outside of any node).
                                                              (line   0)
* Prefix:                                Generating a random float with some properties.
                                                              (line 125)
* Supported platforms:                   (outside of any node).
                                                              (line   0)
* Type name formation:                   Generating a random float with some properties.
                                                              (line 136)



Tag Table:
Node: An Introduction to FPNGlib5425
Ref: An Introduction to FPNGlib-Footnote-16126
Node: Generating Random Integers6228
Ref: Generating Random Integers-Footnote-19208
Node: Generating Random Integers in a Domain9476
Ref: Generating Random Integers in a Domain-Footnote-112516
Ref: Generating Random Integers in a Domain-Footnote-212589
Ref: Generating Random Integers in a Domain-Footnote-312721
Node: Generating Random Floating-Point Numbers12815
Ref: exa:mcpi16547
Ref: Generating Random Floating-Point Numbers-Footnote-117746
Ref: Generating Random Floating-Point Numbers-Footnote-217848
Ref: Generating Random Floating-Point Numbers-Footnote-317898
Node: Generating a random float with some properties18047
Ref: Generating a random float with some properties-Footnote-124606
Node: Integer Random Generators24740
Node: Wrapping an IRNG30502
Node: Integer RNGs available32794
Ref: fig:classes41601

End Tag Table
