\input texinfo @c -*-texinfo-*-
@c %**start of header
@c @afourpaper
@setfilename fpnglib.info
@include version.texi
@settitle The FPNGlib Library
@finalout
@c -@setchapternewpage odd
@c %**end of header

@titlepage
@title The FPNGlib Manual
@subtitle Version @value{VERSION}
@subtitle Updated @value{UPDATED}
@author Fr@'ed@'eric Goualard
LS2N UMR CNRS 6004, University of Nantes, France

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2019,2020 University of Nantes, France

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Foundation.
@end titlepage

@shortcontents

@contents

@node What is FPNGlib?
@chapter What is FPNGlib?
@c ======================

FPNGlib is a C library that offers pseudo-random generators in a unified framework. As the name implies, its strong point is the availability of many IEEE@tie{}754@footnote{@i{IEEE Standard for Floating-Point Arithmetic. IEEE STD 754-2008}. IEEE Computer Society, 2008.} floating-point random number generators, with the possibility to control the characteristics of the floating-point numbers generated (e.g., the amount of subnormal vs. normal, or the probability of having a least significant bit of the fractional part to be @math{1})

Even though it is entirely written in ISO Standard C99, FPNGlib is, at present, only supported on UNIX-like systems (GNU/Linux and Mac@tie{}OS@tie{}X are the only two tested environments) due to the tools used for its configuration, compilation and deployment (@emph{autotools}).
@cindex Supported platforms

This manual assumes a basic knowledge of the IEEE@tie{}754 standard and refers to the internal representation of floating-point numbers in several places. Readers unfamiliar with the standard may find beneficial to at least read its @url{https://en.wikipedia.org/wiki/IEEE_754,Wikipedia entry} first.

The FPNGlib library contains code from third parties, specifically:
@itemize @bullet
@item @url{https://maths-people.anu.edu.au/~brent/random.html,xorgens 3.06} by Richard Brent, licenced under the @url{http://www.gnu.org/copyleft/gpl.html,GNU General Public License};
@item Both 64-bit and 32-bit versions of the @url{http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html,Mersenne twister}, by Takuji Nishimura and Makoto Matsumoto, whose licenses can be found in files @file{src/mt19937-64.c} and @file{src/mt19937ar.c}.
@end itemize

Additionally, the implementation of the Walker/Vose algorithm in @code{src/walker_vose.c} is mostly a reimplementation in C of the Java version by Keith Schwarz (@url{https://www.keithschwarz.com/interesting/code/?dir=alias-method}). Some code is also directly taken from the @url{https://www.gnu.org/software/gsl/,GNU GSL 2.6} implementation of the same.

The FPNGlib library is licensed under the terms of the @url{https://www.gnu.org/licenses/lgpl-3.0.en.html,GNU Lesser General Public License v.3 or later}, except from third party code, which comes with its own license. More information about the FPNGlib library can be found at the project homepage, @uref{https://gitlab.univ-nantes.fr/goualard-f/fpnglib}.



@unnumberedsec A Word of Caution
@cindex Cryptographic use
FPNGlib does not contain any truly random number generator as its focus is on reproducibility for applications such as Monte-Carlo algorithms. As a consequence, it is not suited for cryptographic applications.

@unnumberedsec Reporting a Bug
@cindex Bug report

Questions and bug reports shall be directly submitted on the @url{https://gitlab.univ-nantes.fr/goualard-f/fpnglib/issues,GitLab platform} for the project.

@node Getting Started with FPNGlib
@chapter Getting Started with FPNGlib
@c ==================================

This chapter describes the very first steps with FPNGlib, from the retrieval of the archive to the first program you will write to test its potential. If you are accustomed to working with autotools-based software, feel free to proceed directly to @ref{An Introduction to FPNGlib}.

@section Installation
@c ------------------
The FPNGlib library uses the @emph{autotools} (@url{https://www.gnu.org/software/autoconf/,autoconf}, @url{https://www.gnu.org/software/automake/,automake}, @url{https://www.gnu.org/software/libtool/,libtool}) for configuration, compilation, and deployment. However, these tools do not need to be present on your computer as long as you do not modify the configuration files (@file{configure.ac} and the various @file{Makefile.am} files, mostly).

The library is entirely written in the ISO/IEC 9899:1999 C language. Therefore, its compilation requires a sufficiently recent C compiler such as any GNU C Compiler v.@tie{}4.5 or higher.

In order to test the library, you will need to install @command{check} v. 0.11.0 or higher (@url{https://libcheck.github.io/check/}) beforehand. If your compiler does not support
the macro @code{__VA_OPT__}, some tests will not be performed. That macro should be
available in GCC version 8 and above, and in Clang version 6 and above.

Before compiling the library, you need to configure it. This is done by calling the command ``@command{./configure}'' in the root directory of FPNGlib. The command accepts many options, among them:

@itemize @w{}
@item @option{--help}: display a list of all the options available;
@item @option{--prefix=@var{<path to install into>}}: give the path to install the code into. The header files will go into an @file{include/} subdirectory, while the library will go into a @file{lib/} subdirectory;
@item @option{--enable-debug=@var{[yes/info/profile/no]}}: define whether the code should be compiled with debug information and assertion support. The default is @samp{no}. Debug information and assertions may slightly impact the performances of the library if enabled.
@end itemize
There are many other options, shared by all autotools-based applications. Use ``@command{./configure --help}'' to get the complete list.

Once the configuration is complete, you may call ``@command{make}'' in the root directory of FPNGlib to compile the library.

After having compiled the library, you should test it, in order to ensure that everything is ok. This is done by calling ``@command{make check}.'' If no error is detected, you may proceed to the installation phase.

The library should be installed before being used. However, if you want to get a taste of it beforehand, you may modify and execute the examples in the subdirectory @command{examples/}, even before the installation. Calling ``@command{make}'' in this directory will recompile the necessary files.

The installation is done by calling ``@command{make install}'' from the top directory of the distribution. By default, the library is installed into @file{/usr/local}. As seen above, this can be changed by using the @option{--enable-debug} option at configuration time.

@page
@node An Introduction to FPNGlib
@section An Introduction to FPNGlib
@c --------------------------------
FPNGlib offers generators for random integers and for both single precision and double precision random IEEE 754 floating-point numbers (@dfn{floats}, for short). We will first see how to obtain random integers in @ref{Generating Random Integers} and @ref{Generating Random Integers in a Domain}, and then random floats in @ref{Generating Random Floating-Point Numbers} and @ref{Generating a random float with some properties}.

@node Generating Random Integers
@subsection Generating Random Integers
@c ...................................
Our very first program using FPNGlib simply draws one integer at random:

@cartouche
@verbatiminclude snippets/isimple.c
@end cartouche

Assuming you have installed FPNGlib locally in some directory @file{$HOME/local} by configuring it with the command @samp{./configure --prefix=$HOME/local}, you may compile the example above by calling @command{gcc} as such:

@example
gcc -I$HOME/local/include -L$HOME/local/lib \
      -o simple simple.c -lfpnglib
@end example
@cindex Compiling with libfpnglib.so

Of course, if both the @emph{include} directory and the @emph{lib} directory paths appear in the relevant environment variables (@env{C_INCLUDE_PATH} and @env{LD_LIBRARY_PATH}, respectively), you may omit the ``@code{-I}'' and ``@code{-L}'' directives entirely.
Alternatively, as long as you work on the example file provided in the @file{doc/snippets} directory of the distribution of the library, you may simply call @command{make isimple} to compile it.

The output of this program should be:
@verbatim
3340206418
11203470090111516746
@end verbatim

In the example above, we use the 32-bit version of the Mersenne Twister MT19937@footnote{@url{http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/earticles.html,@cite{Mersenne Twister: A 623-dimensionally equidistributed uniform pseudorandom number generator, M. Matsumoto and T. Nishimura. ACM Trans. on Modeling and Computer Simulation, 8(1), 1998.}}}, but FPNGlib also offers the 64-bit version, declared in @file{fpnglib/mt19937-64.h}.

Random integers come in two sizes: 32-bit and 64-bit. As exemplified in the example above, both sizes may be created by 32-bit generators as well as 64-bit ones: A 32-bit generator will combine two outputs to return a 64-bit integer; on the other hand, a 64-bit generator will usually split its output into two 32-bit integers and return one of them to produce a 32-bit integer.

All Random Number Generators (@dfn{RNG}) may be initialized by a single integer, the @emph{seed}. In addition, some may be initialized by other means, mostly vectors of integers. It is the case with the Mersenne Twister MT19937, of which an instance may be created with the @code{fpngl_mt19937v32_by_array} function instead of @code{fpngl_mt19937v32}. Both functions return a pointer to an object of the opaque type @code{fpngl_irng32_t}.
@tindex fpngl_irng32_t
Since the implementation of that type is not public, all object of the type must be manipulated through pointers only. This is the rule for most types in FPNGlib.

By calling the function @code{fpngl_irng32_next32}, we compute the next 32-bit
integer. When calling the function @code{fpngl_irng32_next64}, the next two 32-bit integers are computed and combined to produce one 64-bit integer.

The call to @code{fpngl_mt19937v32} allocates some memory from the heap to represent the internal structure of the MT19937 RNG. We need to call @code{fpngl_irng32_delete} to reclaim that memory when the RNG is no longer used.

The 32-bit MT19937 RNG instance was constructed and initialized with the @code{fpngl_mt19937v32} constructor. By using a different constructor, one may choose a different RNG for ones program without having to modify it, apart from the constructor call.

@node Generating Random Integers in a Domain
@subsection Generating Random Integers in a Domain
@c ...............................................
A 32-bit Integer RNG (@dfn{IRNG}, for short) will usually draw an integer in the domain @math{[0,2^{32}-1]} or in some other smaller but still impractically large domain. More often than not, simulations require drawing integers in some precise domain, say @math{[1,6]} to simulate a dice, for example. For such an application, many sources still suggest to draw an integer in the full domain of the RNG and then use the modulo to restrict the output to the correct domain:
@cartouche
@anchor{biased_dice_c}
@verbatiminclude snippets/biased_dice.c
@end cartouche

However, since @math{2^{32} = 6\times 715827882 + 4}, there are @math{715827883} ways to produce the numbers @math{1} to @math{4}, and only @math{715827882} ways to produce the numbers @math{5} and @math{6}, which introduces a @math{1.397\times 10^{-7}}% bias. A very small bias indeed, but one that could become significant if one used a different RNG, such as a @emph{Linear Congruential Generator}@footnote{@cite{@url{https://en.wikipedia.org/wiki/Linear_congruential_generator}}.} (@dfn{LCG}) with a congruence much smaller than @math{2^{32}}.

With FPNGlib, the proper way to generate a random integer in the domain @math{[0,k]}, is to use the @code{fpngl_ubound32} or @code{fpngl_ubound64} functions available in @file{fpnglib/irange.h}, depending on the type of integer expected (@code{uint32_t} or @code{uint64_t}):

@cartouche
@verbatiminclude snippets/dice.c
@end cartouche
Remember that the function @code{fpngl_mt19937v32} creates a 32-bit RNG with type @code{fpngl_irng32_t}. The @code{fpngl_ubound32} function computes a random integer in @math{[0,k-1]}, given @math{k} as its second argument. However, it must accept to do so with both a 32-bit RNG and a 64-bit RNG. We therefore need to encapsulate the actual 32-bit RNG into a ``generic'' RNG of type @code{fpngl_irng_t} with the function @code{fpngl_irng_new32}. The @code{irng} variable owns the 32-bit RNG it encapsulates and is responsible for its deletion, which will be done when we call @code{fpngl_irng_delete} instead of @code{fpngl_irng32_delete}. 

The @code{fpngl_ubound32} function uses the modification by O'Neill@footnote{@i{Efficiently Generating a Number in a Range}, Melissa E. O'Neil, @url{https://www.pcg-random.org/posts/bounded-rands.html}, 2018.} of Lemire's algorithm@footnote{@i{Fast Random Integer Generation in an Interval}, Daniel Lemire, ACM TOMACS 29(1), 2019.} to draw integers in an interval. The @code{fpngl_ubound64} uses the same algorithm, provided a 128 bits integer type
is available on the platform used. Otherwise, it uses slower methods presented by O'Neill at @url{https://www.pcg-random.org/posts/bounded-rands.html}.

To draw integers from a domain @math{[a,b]} instead of @math{[0,k]}, one can use the functions @code{fpngl_range32} and @code{fpngl_range64}. 

@node Generating Random Floating-Point Numbers
@subsection Generating Random Floating-Point Numbers
@c .................................................
One of the strong points of FPNGlib is the generation of IEEE@tie{}754 floating-point numbers@footnote{@i{IEEE Standard for Floating-Point Arithmetic. IEEE STD 754-2008}. IEEE Computer Society, 2008.}. It offers many methods to draw floats in different domains and with various properties.

In the following example, we use an RNG that computes a double precision floating-point number in @math{[0,1)} by drawing first an integer in @math{[0,2^{53}-1]} and then dividing it by @math{2^{53}}.

@cartouche
@verbatiminclude snippets/fsimple.c
@end cartouche

The output of the @code{fpngl_frng64_nextf64} function expressed using the C99 hexadecimal format@footnote{See Section 6.4.4.2 of @i{ISO/IEC 9899:1999}.} is ``@code{0x1.ba7451f95b40fp-1}.''

Floating-point number generators (@dfn{FRNG}s, for short) are either of the type @code{fpngl_frng32_t} when they produce single
precision floats, or @code{fpngl_frng64_t} for double precision. In the same way as for integer generators,
floats generators can only be manipulated through pointers to objects of these types. All generators of either type must implement the same functionalities. In particular, as shown in @ref{exa:mcpi} and in the example above, double precision generators must implement the following calls:
@itemize
@item @code{fpgnl_frng64_name()}: return a constant string corresponding to the name of
      the generator;
@item @code{fpngl_fnrg64_nextf64()}: return the next double precision random number;
@item @code{fpngl_frng64_min()}: return the smallest floating-point value that can
      be computed by the FRNG;
@item @code{fpngl_frng64_max()}: return the largest floating-point value that can
      be computed by the FRNG;
@item @code{fpngl_frng64_delete()}: reclaim the memory used to represent the generator.
@end itemize
As a consequence, it is possible to write functions requiring random floats independently of the FRNG actually used, and to pass it as a parameter (see, e.g., @code{mcpi} in @ref{exa:mcpi}).

Note, however, that FRNGs are not bound to return floats in any prescribed domain: some may return values in ``@math{[0,1)},'' some in ``@math{(0,1)},'' and some others in any other domain. It is then the responsibility of the programmer to choose FRNGs according to the domains they are interested into. Contrary to the custom in the literature on the subject, FPNGlib does not report the domain of an FRNG in terms of an interval with possibly open bounds; since FRNGs compute discrete values and not real ones, it is always possible for the functions @code{fpngl_frng64_min} and @code{fpngl_frng64_max} to return the minimum and maximum that may actually be reached. For example, the @code{fpngl_div53} RNG is able to return all floating-point numbers of the form @math{@{k\times2^{-53}\mid k\in@{0, 1, \dots, 2^{53}-1@}@}}. Consequently, its minimum reported is @math{0} and its maximum @math{1-2^{-53}}.

A classical way to implement FRNGs is to rely on an integer RNG and divide its output by
some integer constant, usually the largest possible integer the RNG can produce or the next integer above. This is what we do to create @code{frng0} in @ref{exa:mcpi}, in which we use a Monte Carlo method to compute with two different RNGs an approximation of @math{\pi} by throwing virtual darts at a unit circle and counting the ones that land in it: firstly, we create an IRNG based on the 32-bit version of the Mersenne Twister MT19937, then we create an FRNG by using the @code{fpngl_bydivision_new64} constructor. That constructor takes three parameters:
@enumerate
@item A name for the newly created FRNG (``@code{FMT19937v32},'' in @ref{exa:mcpi});
@item An IRNG of the type @code{fpngl_irng_t};
@item A divisor by which each random integer should be divided (here, we choose to divide
      by the smallest integer strictly larger than the largest random number that our IRNG can produce, therefore creating a FRNG returning values in @math{[0,1)}@footnote{As a side note, the open bound is guaranteed only if the divisor is smaller than @math{2^{53}}, which is the case here since we use a 32-bit IRNG.}).
@end enumerate

Note that, as is always the case in FPNGlib, the FRNG @code{frng0} created from the IRNG @code{irng32} ``owns'' it and is, therefore, responsible for its destruction. This is why we do not call @code{fpngl_irng_delete} at the end of the program: the call @code{fpngl_frng64_delete(frng0)} is sufficient to reclaim both the memory allocated to represent @code{frng0} and @code{irng32}.

The FRNG created with @code{fpngl_drand48bsd} also relies on the division of the result
of a Linear Congruential Generator by a constant integer. The result is a floating-point number in @math{[0,1)} with 48 bits of entropy only.

@float Example,exa:mcpi
@cartouche
@verbatiminclude snippets/mcpi.c
@end cartouche
@caption{Computing an approximation to @math{\pi} with a Monte Carlo method.}
@end float

@node Generating a random float with some properties
@subsection Generating a random float with some properties
@c .......................................................

For some applications, we are interested in drawing floating-point numbers with some
definite properties only. That might be:
@itemize
@item Only subnormal floats;
@item Only normal floats;
@item Subnormal and normal floats in some precise proportion; 
@item Only positive floats with exponents and fractional parts in
some precise domain;
@item @dots{}
@end itemize

FPNGlib is particularly well suited for this kind of applications as it offers many ways to define the properties the floats should meet.

For example, if only random double precision subnormal floats are required, one can use the @code{fpngl_denormal64} function. For random normal floats, the @code{fpngl_normal64} function can be used:

@cartouche
@verbatiminclude snippets/subnormal.c
@end cartouche

Both functions require an integer RNG, as the subnormal and normal random floats are constructed from their exponent and fractional part fields.

FPNGlib considers five classes of floats:
@itemize
@item @math{\pm0};
@item Subnormal;
@item Normal;
@item @math{\pm\infty};
@item @emph{Not a Number}.
@end itemize
There are generator functions for each of theses classes. In addition, using the @code{fpngl_class_float64_new} function, it is easy to draw floats from these five classes with different probabilities attached to each:
@cartouche
@verbatiminclude snippets/distrib.c
@end cartouche
This program displays 10 floats, with probabilities 12.5% that they are equal to @math{\pm0}, 25% that they are subnormal, 50% that they are normal, and  12.5% that they are infinite.

Note that the object of type @code{fpngl_distribution_t} owns the RNG @var{irng} and is responsible for its destruction. This is why we only call @code{fpngl_distribution_delete} to delete the @var{dist} object, and not @code{fpngl_irng_delete} on @var{irng}.

A more flexible way to draw floats from a specific set is to put constraints on the acceptable sign, exponent and fractional part with the @code{fpngl_float64} function. The following program, for example, will draw 10 double precision floats in @code{[2,4)}:
@cartouche
@verbatiminclude snippets/float64.c
@end cartouche
The first parameter of @code{fpngl_float64} is an integer RNG, which is used to draw the integers defining the sign, exponent and fractional part of the float returned. The second parameter indicates what is the expected sign of the float drawn; It can be one of:
@itemize
@item @code{fpngl_positive} (for drawing only positive floats);
@item @code{fpngl_negative} (for drawing only negative floats);
@item @code{fpngl_whatever} (for either positive or negative floats, with an equiprobability of both).
@end itemize
The third and fourth parameters establish bounds on the @emph{biased} exponent@footnote{The @emph{biased} exponent @math{e} for double precision floats takes its value in @math{[0,2047]}, the actual exponent @math{E} being equal to @math{e-1023}.}. The fifth and sixth parameters establish bounds on the possible values of the fractional part, with @code{fpngl_minfrac64} being the smallest possible value, equal to @code{0x0000000000000}, and @code{fpngl_maxfrac64} being the largest possible value, equal to @code{0xfffffffffffff}. Lastly, the seventh and eighth parameters are masks that are ultimately applied to the fractional part: the seventh parameter is ``@i{and}ed'' with the fractional part and the eighth parameter is ``@i{or}ed'' with that resulting value.

In the example above, we are asking for floats with a positive sign, an exponent of @code{1} (@math{1024} minus the bias of @math{1023}) and a fractional part between  @code{0x0000000000000} and @code{0xfffffffffffff}, that is ---in binary--- floats from @math{+1.0\times2^1} to @math{+1.111111111111111111111111111111111111111111111111111\times2^1}, or in decimal, from @math{2.0} to @math{4.0-2^{-51}}.

@node General Organization of the Library
@chapter General Organization of the Library
@c =========================================

In FPNGlib, all public constants, variables, types, and functions are prefixed with @samp{fpngl_} to make them stand apart in larger programs and avoid name collisions.
@cindex Prefix
 All header files from FPNGlib are in the subdirectory @file{fpnglib/}.
 
All RNGs have types whose name is formed according to the same principle: first the prefix @samp{fpngl_}, then the type of the RNG (@samp{irng} for
an RNG generating integers, and @samp{frng} for an RNG generating floating-point
numbers) followed by the size of the values returned (@samp{32} for 32-bit integers and
single precision floating-point numbers, and @samp{64} for 64-bit integers and
double precision floating-point numbers), and finally the postfix @samp{_t} to mark the name as a type. A slight exception to this scheme is the type @code{fpngl_irng_t} that can wrap 32-bit as well as 64-bit integer RNGs.
@cindex Type name formation

There are at present five Random Number Generator types in FPNGlib:
@itemize
@item@w{}@code{fpngl_irng32_t}. RNG generating 32-bit integers natively;
@tindex fpngl_irng32_t
@item@w{}@code{fpngl_irng64_t}. RNG generating 64-bit integers natively;
@tindex fpngl_irng64_t
@item@w{}@code{fpngl_irng_t}. Wrapper for a RNG generating natively either 32-bit or 64-bit integers;
@tindex fpngl_irng_t
@item@w{}@code{fpngl_frng32_t}. RNG generating single precision (C type ``@code{float}'') IEEE@tie{}754 floating-point numbers;
@tindex fpngl_frng32_t
@item@w{}@code{fpngl_frng64_t}. RNG generating double precision (C type ``@code{double}'') IEEE@tie{}754 floating-point numbers.
@tindex fpngl_frng64_t
@end itemize
Note that both 32-bit and 64-bit integer RNGs can generate 32-bit as well as 64-bit integers with, respectively, the functions @code{fpngl_irng32_next64} and @code{fpngl_irn64_next32}.

The complete state of all the RNGs is entirely contained in an object of one of the abovementioned types. There are no global variables, which means that the user may define and use several RNGs, even of the same type, without any risk of interferences between them.
@cindex Global state

@node Integer Random Generators
@chapter Integer Random Generators
@c ===============================

In this chapter, we present the Random Number Generators capable of producing 32-bit as well as 64-bit integers. They all follow a uniform distribution. Refer to @ref{Non-Uniform Distributions} for other distributions.

Random Number Generators that produce integers must all provide the same services independently of the size of the integers they ``natively'' produce:
@itemize
@item Compute a 32-bit integer;
@item Compute a 64-bit integer;
@item Compute @math{k} random bits, with @math{k} being smaller than the
      size of the integers produced natively by the RNG;
@item Compute an array of 32-bit integers;
@item Compute an array of 64-bit integers;
@item Return the seed used to initialize the RNG;
@item Return the minimum integer the RNG can produce;
@item Return the maximum integer the RNG can produce.
@end itemize

In addition, an RNG must possess a function to release the resources acquired upon
construction of an instance. Each RNG type has its own constructor (@xref{Integer RNGs available}).

In the following, we describe the functions providing these services for RNGs of the type @code{fpngl_irng32_t}, @code{fpngl_irng64_t}, as well as for the wrapper type @code{fpngl_irng_t}. The services specific to this last type are described in @ref{Unsized RNGs}.

@deftypefn {@file{fpnglib/irng32_t.h}} void fpngl_irng32_delete (fpngl_irng32_t* @var{rng})
@deftypefnx {@file{fpnglib/irng64_t.h}} void fpngl_irng64_delete (fpngl_irng64_t* @var{rng})
@deftypefnx {@file{fpnglib/irng_t.h}} void fpngl_irng_delete (fpngl_irng_t* @var{rng})
Releases the resources acquired upon the construction of the RNg @var{rng}. The
parameter @var{rng} must point to an RNG not already released, otherwise the behavior is
undefined. 
@end deftypefn

@deftypefn {@file{fpnglib/irng32_t.h}} uint32_t fpngl_irng32_next32 (fpngl_irng32_t* @var{rng})
@deftypefnx {@file{fpnglib/irng64_t.h}} uint32_t fpngl_irng64_next32 (fpngl_irng64_t* @var{rng})
@deftypefnx {@file{fpnglib/irng_t.h}} uint32_t fpngl_irng_next32 (fpngl_irng_t* @var{rng})
Return the next 32-bit random integer.
A 64-bit RNG will usually compute a 64-bit integer
and return the lower or higher 32 bits.

The behavior is undefined if @var{rng} does not point to some valid RNG.
@end deftypefn

@deftypefn {@file{fpnglib/irng32_t.h}} uint64_t fpngl_irng32_next64 (fpngl_irng32_t* @var{rng})
@deftypefnx {@file{fpnglib/irng64_t.h}} uint64_t fpngl_irng64_next64 (fpngl_irng64_t* @var{rng})
@deftypefnx {@file{fpnglib/irng_t.h}} uint64_t fpngl_irng_next64 (fpngl_irng_t* @var{rng})
Return the next 64-bit random integer. A 32-bit RNG will be called twice
to create a 64-bit integer.

The behavior is undefined if @var{rng} does not point to some valid RNG.
@end deftypefn

@deftypefn {@file{fpnglib/irng32_t.h}} uint32_t fpngl_irng32_nextk @
           (fpngl_irng32_t* @var{rng}, uint32_t @var{k})
@deftypefnx {@file{fpnglib/irng64_t.h}} uint64_t fpngl_irng64_nextk @
            (fpngl_irng64_t* @var{rng}, uint32_t @var{k})
@deftypefnx {@file{fpnglib/irng_t.h}} uint64_t fpngl_irng_nextk @
            (fpngl_irng_t* @var{rng}, uint32_t @var{k})
Return the next @var{k} random bits. The maximum value of @var{k} depends on the
type of RNG:
@itemize
@item @var{k}@math{\in[0,32]} for a 32-bit RNG;
@item @var{k}@math{\in[0,64]} for a 64-bit RNG;
@item @var{k}@math{\in[0,64]} for a wrapped RNG of type @code{fpngl_irng_t}.
@end itemize

Note that @var{k} may be greater than 32 for a 32-bit RNG when it is wrapped
in an RNG of type @code{fpngl_irng_t}. In that case, the RNG is called twice and
the two outputs are aggregated to form the result.
@end deftypefn

@deftypefn {@file{fpnglib/irng32_t.h}} void fpngl_irng32_array32 @
           (fpngl_irng32_t* @var{rng}, uint32_t* @var{T}, uint32_t @var{n})
@deftypefnx {@file{fpnglib/irng64_t.h}} void fpngl_irng64_array32 @
           (fpngl_irng64_t* @var{rng}, uint32_t* @var{T}, uint32_t @var{n})
@deftypefnx {@file{fpnglib/irng_t.h}} void fpngl_irng_array32 @
           (fpngl_irng_t* @var{rng}, uint32_t* @var{T}, uint32_t @var{n})
Fill the array @var{T} with @var{n} 32-bit random integers. The array @var{T} must
have been allocated to the correct size before the call.

The speed-up obtained with this function, compared with calling @var{n} times a
@code{*_next32} function depends on the RNG used. For most implementations, a 64-bit
RNG will be called at most @math{@var{n}/2} times and each 64-bit integer split into
two 32-bit integers to fill adjacent positions in the array. Some RNGs do have dedicated
fast implementations of this function (refer to their documentation).
@end deftypefn

@deftypefn {@file{fpnglib/irng32_t.h}} void fpngl_irng32_array64 @
           (fpngl_irng32_t* @var{rng}, uint64_t* @var{T}, uint32_t @var{n})
@deftypefnx {@file{fpnglib/irng64_t.h}} void fpngl_irng64_array64 @
           (fpngl_irng64_t* @var{rng}, uint64_t* @var{T}, uint32_t @var{n})
@deftypefnx {@file{fpnglib/irng_t.h}} void fpngl_irng_array64 @
           (fpngl_irng_t* @var{rng}, uint64_t* @var{T}, uint32_t @var{n})
Fill the array @var{T} with @var{n} 64-bit random integers. The array @var{T} must
have been allocated to the correct size before the call.

The speed-up obtained with this function, compared with calling @var{n} times a
@code{*_next64} function depends on the RNG used. For most implementations, a 32-bit
RNG will be called @math{2@var{n}} times. Some RNGs do have dedicated
fast implementations of this function (refer to their documentation).
@end deftypefn

@deftypefn {@file{fpnglib/irng32_t.h}} uint32_t fpngl_irng32_seed (fpngl_irng32_t* @var{rng})
@deftypefnx {@file{fpnglib/irng64_t.h}} uint64_t fpngl_irng64_seed (fpngl_irng64_t* @var{rng})
@deftypefnx {@file{fpnglib/irng_t.h}} uint64_t fpngl_irng32_seed (fpngl_irng_t* @var{rng})
Return the value used to initialize the RNG. Some RNGs are not initialized by a single
integer value (e.g., the 32-bit MT19937 RNG created with @code{fpngl_mt19937v32_by_array}). In that case, that function will return ``@code{0}.''
@end deftypefn

@deftypefn {@file{fpnglib/irng32_t.h}} {const char*} fpngl_irng32_name @
           (fpngl_irng32_t* @var{rng})
@deftypefnx {@file{fpnglib/irng64_t.h}} {const char*} fpngl_irng64_name @
           (fpngl_irng64_t* @var{rng})
@deftypefnx {@file{fpnglib/irng_t.h}} {const char*} fpngl_irng_name @
           (fpngl_irng_t* @var{rng})
Return a pointer to a constant string representing the name of the RNG. Refer to each constructor in @ref{Integer RNGs available} to know the possible values.
@end deftypefn

@deftypefn {@file{fpnglib/irng32_t.h}} uint32_t fpngl_irng32_min @
           (fpngl_irng32_t* @var{rng})
@deftypefnx {@file{fpnglib/irng64_t.h}} uint64_t fpngl_irng64_min @
           (fpngl_irng64_t* @var{rng})
@deftypefnx {@file{fpnglib/irng_t.h}} uint64_t fpngl_irng_min @
           (fpngl_irng_t* @var{rng})
Return the smallest integer that can be drawn with the RNG.
@end deftypefn

@deftypefn {@file{fpnglib/irng32_t.h}} uint32_t fpngl_irng32_max @
           (fpngl_irng32_t* @var{rng})
@deftypefnx {@file{fpnglib/irng64_t.h}} uint64_t fpngl_irng64_max @
           (fpngl_irng64_t* @var{rng})
@deftypefnx {@file{fpnglib/irng_t.h}} uint64_t fpngl_irng_max @
           (fpngl_irng_t* @var{rng})
Return the largest integer that can be drawn with the RNG.
@end deftypefn

@deftypefn {@file{fpnglib/irng_t.h}} bool fpngl_is_irng32 (fpngl_irng_t* @var{rng})
@deftypefnx {@file{fpnglib/irng_t.h}} bool fpngl_is_irng64 (fpngl_irng_t* @var{rng})
Return @code{true} if the wrapped RNG is, respectively, of the type
@code{fpngl_irng32_t} or @code{fpngl_irng64_t}.
@end deftypefn

@node Unsized RNGs
@section Unsized RNGs
@c ----------------------
Since both 32-bit and 64-bit RNGs can produce 32-bit as well as 64-bit integers, users may be tempted to write programs that use an RNG, irrespective of its type. The @code{fpngl_irng_t} type serves as a wrapper around 32-bit and 64-bit RNGs to abstract their real limitations. An object of that type is constructed from an actual RNG of type @code{fpngl_irng32_t} or @code{fpngl_irng64_t} with, respectively, the functions @code{fpngl_irng_new32} and @code{fpngl_irng_new64}. @ref{exa:irng} shows how to write a function @code{draw_twice} that takes as input both 32-bit and 64-bit RNGs wrapped in a @code{fpngl_irng_t} type.

@float Example,exa:irng
@cartouche
@verbatiminclude snippets/irng.c
@end cartouche
@caption{Wrapping 32-bit and 64-bit RNGs in a @code{fpngl_irng_t} object.}
@end float

Note that the new RNG constructed @var{irng} ``owns'' the RNG passed as a parameter to @code{fpngl_irng_new32} or @code{fpngl_irng_new64} constructor, and is responsible for its proper disposal. The release of resources is then done with @code{fpngl_irng_delete} only.

@deftypefn {@file{fpnglib/irng_t.h}} fpngl_irng_t* fpngl_irng_new32 @
           (fpngl_irng32_t* @var{irng32})
@deftypefnx {@file{fpnglib/irng_t.h}} fpngl_irng_t* fpngl_irng_new64 @
            (fpngl_irng64_t* @var{irng64})
Wrap an 32-bit or 64-bit RNG into an @code{fpngl_irng_t} object. The new object
is responsible for the destruction of the RNG passed as a parameter. Consequently,
@var{irng32} (resp.@tie{}@var{irng64}) should not be deleted with @code{fpngl_irng32_delete} (resp.@tie{}@code{fpngl_irng64_delete}) afterwards.
@end deftypefn

There is also a function to draw an integer of the size supported natively by the
wrapped RNG:

@deftypefn {Library Function} uint64_t fpngl_irng_next (fpngl_irng_t* @var{rng})
This function is unique to the @code{fpngl_irng_t} type. If the RNG wrapped is of type @code{fpngl_irng64_t}, it behaves like @code{fpngl_irng_next64}, otherwise it returns the
integer computed with @code{fpngl_irng_next32} cast to 64 bits.
@end deftypefn

@node Integer RNGs available
@section Integer RNGs available
@c ----------------------------
The number of integer Random Number Generators augments regularly with new versions of FPNGlib. @ref{tab:irngs} summarizes the characteristics of the integer RNGs implemented in the current version of the library, with the following meanings for the columns:
@itemize
@item@w{}@b{Name}. The name of the RNG as reported by @code{fpngl_irng32_name} for the 32-bit RNGs and @code{fpngl_irng64_name} for the 64-bit RNGs;
@item@w{}@b{Size}. Size, in bits, of the integers that are natively created by the RNG;
@item@w{}@b{Min}. Value of the smallest integer that can returned by the RNG;
@item@w{}@b{Max}. Value of the largest integer that can returned by the RNG;
@item@w{}@b{Period}. Number of integers that can be drawn before a sequence repeats itself.
@end itemize


@float Table,tab:irngs
@caption{Integer RNGs available in FPNGlib@tie{}@value{VERSION} and their characteristics.}
@tex\hrule
@end tex
@multitable @columnfractions .4 .15 .15 .15 .15
@headitem Name @tab Size @tab Min. @tab Max. @tab Period
@item @code{drand48_lcg64} @tab 64 @tab 0 @tab @math{2^{48}-1} @tab ?
@item @code{gnu_lcg64} @tab 64 @tab 0 @tab @math{2^{31}-1} @tab ?
@item @code{minstd64} @tab 64 @tab 0 @tab @math{2^{31}-2} @tab ?
@item @code{mt19937v32} @tab 32 @tab 0 @tab @math{2^{32}-1} @tab ?
@item @code{mt19937v64} @tab 64 @tab 0 @tab @math{2^{64}-1} @tab ?
@item @code{mupad_lcg64} @tab 64 @tab 0 @tab @math{10^{12}-12} @tab ?
@item @code{randu64} @tab 64 @tab 0 @tab  @math{2^{31}-1} @tab ?
@item @code{von neumann/metropolis} @tab 32 @tab 0 @tab @math{2^{32}-1} @tab ?
@item @code{xor4096iv32} @tab 32 @tab 0 @tab @math{2^{32}-1} @tab ?
@item @code{xor4096iv64} @tab 64 @tab 0 @tab @math{2^{64}-1} @tab ?
@end multitable
@tex\hrule
@end tex
@end float

@subsection 32-bit Integer RNGs
@c .............................
The following constructors create an integer RNG initialized with a seed, which can be one integer or an array of integers.

@deftypefn {@file{fpnglib/irng32_vnm.h}} fpngl_irng32_t* fpngl_von_neumann_metropolis @
           (uint32_t @var{seed})
Create a 32-bit RNG using the algorithm described in @cite{Various techniques used in connection with random digits. John von Neumann. In A.S. Householder, G.E. Forsythe, and H.H. Germond, eds. Monte Carlo Method, National Bureau of Standards Applied Mathematics Series, vol. 12:pp. 36--38}.

The value of @var{seed} should be greater than 255, and preferably much larger than that, otherwise the RNG will only return 0.

This is not a very good RNG; it is only provided for its historical interest.
@end deftypefn

@deftypefn {@file{fpnglib/mt19937ar.h}} fpngl_irng32_t* fpngl_mt19937v32 (uint32_t @var{seed})
@deftypefnx {@file{fpnglib/mt19937ar.h}} fpngl_irng32_t* fpngl_mt19937v32_by_array @
           (const uint32_t @var{init_key[]}, uint32_t @var{key_length})
This is the 32-bit version of the Mersenne Twister MT19937 by Nishimura & Matsumoto. It can be initialized either by a single integer, or by an array of integers. For maximum entropy, the array should have a size at least equal to 624, but smaller arrays are allowed.

The function @code{fpngl_irng32_seed} will return @code{0} if the RNG is initialized with an array.
@end deftypefn

@deftypefn {@file{fpnglib/xorgens.h}} fpngl_irng32_t* fpngl_xor4096iv32 (uint32_t @var{seed})
This is the 32-bit implementation of the @code{xor4096i} algorithm by Richard P. Brent.
@end deftypefn


@subsection 64-bit Integer RNGs
@c .............................


@deftypefn {@file{fpnglib/lcg.h}} fpngl_irng64_t*  fpngl_minstd64 (uint64_t @var{seed})
MINSTD implementation of Park & Miller Linear Congruential Generator:

@tex
$$a_i = 16807a_{i-1}\,\, {\rm mod}\,\, (2^{31}-1)$$
@end tex

See: @cite{Random Number Generators: Good Ones Are Hard to Find. S. K. Park and K.W. Miller. Comm. ACM 31(10), 1988}.
@end deftypefn


@deftypefn {@file{fpnglib/lcg.h}} fpngl_irng64_t*  fpngl_gnuc_lcg64 (uint64_t @var{seed})
RNG used in the implementation of the GNU libc @code{rand} function:

@tex
$$a_i = 1103515245a_{i-1} + 12345 \,\, {\rm mod}\,\, 2^{31}$$
@end tex

This RNG is no longer the default implementation for @code{rand} in GNU libc as of v. 2.29.
@end deftypefn


@deftypefn {@file{fpnglib/lcg.h}} fpngl_irng64_t*  fpngl_randu64 (uint64_t @var{seed})
This is the 64-bit implementation of the RNG called ``@code{RANDU}'' in the @emph{Scientific Subroutine Package on IBM Mainframe}:

@tex
$$a_i = 65539a_{i-1} \,\, {\rm mod}\,\, 2^{31}$$
@end tex


See: @cite{Numerical Computing with MATLAB. Steve Moler. Chap. 9}.
@end deftypefn

@deftypefn {@file{fpnglib/lcg.h}} fpngl_irng64_t*  fpngl_drand48_lcg64 (uint64_t @var{seed})
RNG used by the GNU and FreeBSD implementations of the function @code{drand48}. It is also used by @code{java.util.Random}. It is an LCG with formula:

@tex
$$a_i = 25214903917a_{i-1} + 11 \,\, {\rm mod}\,\, 2^{48}$$
@end tex
@end deftypefn

@deftypefn {@file{fpnglib/lcg.h}} fpngl_irng64_t*  fpngl_mupad_lcg64 (uint64_t @var{seed})
RNG used in MuPAD Pro 3.1 and Maple 10. This is an LCG with formula:

@tex
$$a_i = 427419669081a_{i-1} \,\, {\rm mod}\,\, (10^{12}-11)$$
@end tex

@end deftypefn

@deftypefn {@file{fpnglib/mt19937-64.h}} fpngl_irng64_t* fpngl_mt19937v64 (uint64_t @var{seed})
@deftypefnx {@code{"mt19937v64"}} fpngl_irng64_t* fpngl_mt19937v64_by_array @
           (const uint64_t @var{init_key[]}, uint64_t @var{key_length})
This is the 64-bit version of the Mersenne Twister MT19937 by Nishimura & Matsumoto. It can be initialized either by a single integer, or by an array of integers. For maximum entropy, the array should have a size at least equal to 312, but smaller arrays are allowed.

The function @code{fpngl_irng_seed} will return @code{0} if the RNG is initialized with an array.
@end deftypefn

@deftypefn {@file{fpnglib/xorgens.h}} fpngl_irng64_t* fpngl_xor4096iv64 (uint64_t @var{seed})
This is the 64-bit implementation of the @code{xor4096i} algorithm by Richard P. Brent.
@end deftypefn

@node Random Integers in a Range
@section Random Integers in a Range
@c --------------------------------

Most RNGs of @ref{Integer RNGs available} return random integers drawn from a large domain (typically @math{[0,2^{32}-1]} or @math{[0,2^{64}-1]}). Many applications, however, require random integers from much smaller domains, e.g., to model dice throwing, coin tossing, @enddots{} An oft quoted tentative answer to the problem is to use the modulo operation, as in @ref{biased_dice_c,,Program @file{biased_dice.c}}. As already discussed for that program, this approach is biased whenever the number of values in the original domain of the RNG is not a multiple of the modulus. Even if it is a multiple of the modulus, the modulo operation extracts the low-order bits of the random integer, which are the least ``random'' ones for many RNGs.

FPNGlib offers four different functions to compute random numbers in a ``small'' domain, depending on the size of the integers required and the bounds of the domain: if the domain is of the form ``@math{[0,a)}'', use the following functions:

@deftypefn {@file{fpnglib/irange.h}} uint32_t fpngl_ubound32 @
           (fpngl_irng_t* @var{rng}, uint32_t @var{a})
@deftypefnx {@file{fpnglib/irange.h}} uint64_t fpngl_ubound64 @
            (fpngl_irng_t* @var{rng}, uint64_t @var{a})
Use the RNG @var{rng} to draw an integer uniformly at random in the domain @math{[0,a)}.

These functions use an efficient algorithm by D. Lemire presented in @cite{``Fast Random Integer Generation in an Interval.'' Daniel Lemire. ACM Transactions on Modeling and Computer Simulation, 29(1), 2019} with modifications by M.E. O'Neill proposed in @cite{``Efficiently Generating a Number in a Range''. @url{https://www.pcg-random.org/posts/bounded-rands.html}. 2018-07-22. [Retrieved 2020-03-12]}.

The function @code{fpngl_ubound64} may be slower when the computer does not offer 128 bits integers natively.

Note that, for both functions, no provision is made to ensure that @var{a} is smaller than the largest integer that can be computed by @var{rng}, @code{fpngl_irng_max(rng)}. It is up to the user to check that this precondition is met.
@end deftypefn



When the domain considered is of the form @math{[a,b)}, with @math{a} and @math{b} potentially negative integers, use the following functions:

@deftypefn {@file{fpnglib/irange.h}} int32_t fpngl_range32 @
           (fpngl_irng_t* @var{rng}, int32_t @var{a}, int32_t @var{b})
@deftypefnx {@file{fpnglib/irange.h}} int64_t fpngl_range64 @
           (fpngl_irng_t* @var{rng}, int64_t @var{a}, int64_t @var{b})
Use the RNG @var{rng} to draw integers uniformly at random in the domain @math{[@var{a},@var{b})}.

These functions rely, respectively, on functions @code{fpngl_ubound32} and @code{fpngl_ubound64} to compute random integers in the domain @math{[0, b-a)} and then shift it by @var{a}.
@end deftypefn      


@node Non-Uniform Distributions
@section Non-Uniform Distributions
@c -------------------------------

All the RNGs presented in @ref{Integer RNGs available} return integers drawn uniformly at random in their domain of definition. It is sometimes necessary to consider other distributions. At present, FPNGlib only allows to draw integers from a discrete distribution. Consider, for example, the modeling of a biased dice with the probabilities shown in @ref{fig:biased_dice}.

@float Figure,fig:biased_dice
@center @image{fpnglib-figures/discrete_distribution,3in,}
@caption{Biased dice modeled with a discrete probability distribution}
@end float

@float Example, exa:biased2
@cartouche
@verbatiminclude snippets/biased_dice_2.c
@end cartouche
@caption{Biased dice with discrete distribution probability for the faces.}
@end float

A discrete probability distribution is created by calling the @code{fpnlg_distribution_new} function with an integer RNG and an array of probabilities as parameters. It returns an object of type @code{fpngl_distribution_t}, which can be used to draw 32-bit random integers following the distribution embodied by the array of probabilities. @ref{exa:biased2} draws @var{ndraws} values with the loaded dice from @ref{fig:biased_dice} and computes the probability of each face to occur. 

@exdent The output of the program in @ref{exa:biased2} is:
@verbatim
0.0999 0.199 0.0999 0.1 0.3 0.2
@end verbatim


@noindent which is very close to the distribution expected (@code{[0.1, 0.2, 0.1, 0.1, 0.3, 0.2]}).

@deftypefn {@file{fpnglib/discrete_distribution.h}} fpngl_distribution_t* @
           fpngl_distribution_new @
           (fpngl_irng_t* @var{rng}, const double @var{P}[], uint32_t @var{szP})
Construct a discrete distribution with probability @var{P}@code{[i]} of drawing the integer @code{i}. The array @var{P} must have at least @var{szP} elements, where @var{szP} must be lower or equal to @math{2^{30}} (The limit on @var{szP} is due to the use of the @code{uistack_t} type, which has a similar implementation-motivated limit). The sum of all values in @var{P} must be equal to 1.
          
The current implementation uses the Walker/Vose alias method with linear complexity.@footnote{@cite{``An Efficient Method for Generating Discrete Random Variables with General Distributions.'' A.J. Walker. ACM Transactions on Mathematical Software. 3 (3): 253–256, 1977} and @cite{``A linear algorithm for generating random numbers with a given distribution.'' M.D. Vose. IEEE Transactions on Software Engineering. 17 (9): 972–975}}

The ownership of the integer RNG @var{rng} is transferred to the @code{fpngl_distribution_t} object, which is responsible for its disposal.
@end deftypefn

@deftypefn {@file{fpnglib/discrete_distribution.h}} void fpngl_distribution_delete @
           (fpngl_distribution_t* @var{dist})
Reclaim the memory allocated to represent a discrete distribution. It also reclaims the memory used to represent the RNG passed upon its construction.
@end deftypefn

@deftypefn {@file{fpnglib/discrete_distribution.h}} uint32_t fpngl_distribution_next32 @
           (fpngl_distribution_t *@var{dist})
Return a random 32-bit integer according to the discrete distribution @var{dist}.
@end deftypefn

@node Floating-Point Random Generators
@chapter Floating-Point Random Generators
@c ======================================

The standard libraries of most programming languages offers only one algorithm to compute random IEEE@tie{}754 floating-point numbers. Usually, it computes floats by dividing random integers by some constant. This imparts a specific structure to the fractional parts of the floats, which may adversely impact programs that use them.@footnote{@cite{``Generating Random Floating-Point Numbers by Dividing Integers: a Case Study'', Fr@'ed@'eric Goualard. In proceedings of the International Conference on Computational Science (ICCS 2020). Lecture Notes in Computer Science, Springer, June 2020.}}

FPNGlib gives the user the choice of the method used to produce floats. All float RNGs are either of the type @code{fpngl_frng32_t}, when they produce single precision floats, or @code{fpngl_frng64_t}, for double precision floats; they must all propose the same functionalities:

@deftypefn {@file{fpnglib/frng32_t.h}} void fpngl_frng32_delete (fpngl_frng32_t* @var{rng})
@deftypefnx {@file{fpnglib/frng64_t.h}} void fpngl_frng64_delete (fpngl_frng64_t* @var{rng})
Reclaim the memory allocated to the RNG @var{rng}. If it was constructed with an
integer RNG, the memory for that one is also reclaimed since float RNGs ``own'' the
integer RNGs they are built with.
@end deftypefn

@deftypefn {@file{fpnglib/frng32_t.h}} float fpngl_frng32_min (fpngl_frng32_t* @var{rng})
@deftypefnx {@file{fpnglib/frng32_t.h}} float fpngl_frng32_max (fpngl_frng32_t* @var{rng})
@deftypefnx {@file{fpnglib/frng64_t.h}} double fpngl_frng64_min (fpngl_frng64_t* @var{rng})
@deftypefnx {@file{fpnglib/frng64_t.h}} double fpngl_frng64_max (fpngl_frng64_t* @var{rng})
Return, respectively, the minimum and the maximum possible values drawn by the
floating-point RNG.

In the literature, many FRNGs are described as returning values in the domain
@math{[0,1)}. Technically, their actual domain is not an interval but a set of discrete values. It is then always possible to describe the domain with closed brackets. The functions ``@code{*_min}'' and ``@code{*_max}'' return, respectively, the smallest and largest values in this set.
@end deftypefn

@deftypefn {@file{fpnglib/frng32_t.h}} float fpngl_frng32_nextf32 (fpngl_frng32_t* @var{rng})
@deftypefnx {@file{fpnglib/frng64_t.h}} double fpngl_frng64_nextf64 (fpngl_frng64_t* @var{rng})
Return the next random floating-point number uniformly drawn from, respectively,
the domain @code{[fpngl_frng32_min(rng), fpngl_frng32_max(rng)]}, or the domain
@code{[fpngl_frng64_min(rng), fpngl_frng64_max(rng)]}.
@end deftypefn

@deftypefn {@file{fpnglib/frng32_t.h}} float fpngl_frng32_next_arrayf32 @
           (fpngl_frng32_t* @var{rng}, float *@var{T}, uint32_t @var{n})
@deftypefnx {@file{fpnglib/frng64_t.h}} double fpngl_frng64_next_arrayf64 @
            (fpngl_frng64_t* @var{rng}, double *@var{T}, uint32_t @var{n})
Fill the array @var{T} with @var{n} random floating-point numbers drawn with the FRNG
@var{rng}.

@strong{Caution}: some FRNGs may allocate a temporary array of size @math{2\times@var{n}} to implement this function. 
@end deftypefn

@deftypefn {@file{fpnglib/frng32_t.h}} {const char*} fpngl_fprng32_name @
           (fpngl_frng32_t* @var{rng})
@deftypefnx {@file{fpnglib/frng64_t.h}} {const char*} fpngl_fprng64_name @
            (fpngl_frng64_t* @var{rng})
Return the string corresponding to the name of the FRNG (@xref{Existing float RNGs}).
@end deftypefn

@deftypefn {@file{fpnglib/frng32_t.h}} uint32_t fpngl_fprng32_seed @
           (fpngl_frng32_t* @var{rng})
@deftypefnx {@file{fpnglib/frng64_t.h}} uint64_t fpngl_fprng64_seed @
            (fpngl_frng64_t* @var{rng})
Return the integer used to initialize the FRNG.
@end deftypefn


@node Existing float RNGs
@section Existing float RNGs
@c -------------------------

@node Single Precision FRNGs
@subsection Single Precision FRNGs
@c ...............................

@deftypefn {@file{fpnglib/xorgens.h}} fpngl_frng32_t* fpngl_xor4096rv32 @
           (uint32_t @var{seed})
           ??
@end deftypefn           


@node Double Precision FRNGs
@subsection Double Precision FRNGs
@c ...............................

@deftypefn {@file{fpnglib/frng64_division.h}} fpngl_frng64_t* fpngl_matlabp5 (uint64_t @var{seed})
Double precision FRNG used by MATLAB until MATLAB 5.

@end deftypefn

@deftypefn {@file{fpnglib/frng64_division.h}} fpngl_frng64_t* fpngl_drand48bsd @
           (uint64_t @var{seed})
Implementation of the POSIX function @code{drand48} in FreeBSD.
@end deftypefn

@deftypefn {@file{fpnglib/frng64_division.h}} fpngl_frng64_t* fpngl_mupad @
           (uint64_t @var{seed})
Generator used in Maple 10 and MuPAD Pro 3.1.
@end deftypefn

@deftypefn {@file{fpnglib/frng64_division_k.h}} fpngl_frng64_t* fpngl_div53 @
           (fpngl_irng_t* @var{irng}, uint64_t @var{seed})
Draw a double precision number in the domain @math{@{0@}\cup@{2^{-53},1-2^{-53}@}} by
dividing an integer generated with the IRNG @var{irng} by @math{2^{53}}.
@end deftypefn

@deftypefn {@file{fpnglib/frng64_division_k.h}} fpngl_frng64_t* fpngl_div32 @
           (fpngl_irng_t* @var{irng}, uint64_t @var{seed})
Draw a double precision number in the domain @math{@{0@}\cup@{2^{-32},1-2^{-32}@}} by
dividing an integer generated with the IRNG @var{irng} by @math{2^{32}}.
@end deftypefn

@deftypefn {@file{fpnglib/frng64_drand48gnu.h}} fpngl_frng64_t* fpngl_drand48gnu @
           (uint64_t @var{seed})
Implementation of the POSIX @code{drand48} function as implemented in GNU @command{gcc}.
@end deftypefn

@deftypefn {@file{fpnglib/frng64_fog97.h}} fpngl_frng64_t* fpngl_fog97 @
           (fpngl_irng_t* @var{irng}, uint64_t @var{seed})
Computation of a double precision number in @math{[0,1-2^{-52}]}
by generating a 52 bits random
fractional part, concatenating it with an exponent of @math{0} to obtain
a float in @math{[1,2-2^{-52}]}, and then subtracting @math{1.0} from it. 
@end deftypefn           

@deftypefn {@file{fpnglib/frng64_fog05.h}} fpngl_frng64_t* fpngl_fog05 @
           (fpngl_irng_t* @var{irng}, uint64_t @var{seed})
           ??
@end deftypefn           

@deftypefn {@file{fpnglib/frng64_golang.h}} fpngl_frng64_t* fpngl_golang @
           (fpngl_irng_t* @var{irng}, uint64_t @var{seed})
           ??
@end deftypefn           

@deftypefn {@file{fpnglib/frng64_java.h}} fpngl_frng64_t* fpngl_java @
           (uint64_t @var{seed})
           ??
@end deftypefn           

@deftypefn {@file{fpnglib/frng64_KGW.h}} fpngl_frng64_t* fpngl_KGW @
           (fpngl_irng_t* @var{irng}, uint64_t @var{seed})
           ??
@end deftypefn           

@deftypefn {@file{fpnglib/frng64_lecuyer_simard.h}} fpngl_frng64_t* fpngl_lecuyer_simard @
           (fpngl_irng_t* @var{irng}, uint64_t @var{seed})
           ??
@end deftypefn

@deftypefn {@file{fpnglib/frng64_rationalLCG10.h}} fpngl_frng64_t* fpngl_rationalLCG10 @
           (uint64_t @var{seed})
           ??
@end deftypefn           

@deftypefn {@file{fpnglib/xorgens.h}} fpngl_frng64_t* fpngl_xor4096rv64 @
           (uint64_t @var{seed})
           ??
@end deftypefn           

@node Drawing floats in a class
@section Drawing floats in a class
@c -------------------------------

@deftypefn {@file{fpnglib/float64.h}} double fpngl_subnormal64 (fpngl_irng_t* @var{rng})
Return a random double precision subnormal number drawn uniformly from the domain 
@math{(-@code{fpngl_lambda64()}, @code{fpngl_lambda64()})}.
@end deftypefn

@deftypefn {@file{fpnglib/float64.h}} double fpngl_zero64 (fpngl_irng_t* @var{rng})
Return zero in double precision as @math{+0.0} or @math{-0.0} with even probability.
@end deftypefn

@deftypefn {@file{fpnglib/float64.h}} double fpngl_inf64 (fpngl_irng_t* @var{rng})
Return the double precision value reserved for infinity as @math{+\infty} or
@math{-\infty} with even probability.
@end deftypefn

@deftypefn {@file{fpnglib/float64.h}} double fpngl_normal64 (fpngl_irng_t* @var{rng})
Return a random double precision number drawn uniformly in the domain
@math{[-@code{fpngl_max64()}, -@code{fpngl_lambda64()}]\cup[@code{fpngl_lambda64()}, @code{fpngl_max64()}]}.
@end deftypefn

@deftypefn {@file{fpnglib/float64.h}} double fpngl_nan64 (fpngl_irng_t* @var{rng})
Return randomly one of the @math{2^{53}-2} possible @emph{Not-A-Number} double precision
values.
@end deftypefn


@deftypefn {@file{fpnglib/float64.h}} double fpngl_float64 @
           (fpngl_irng_t* @var{rng},@
					  fpngl_sign_t @var{s},@
					  uint32_t @var{minexp}, uint32_t @var{maxexp},@
					  uint64_t @var{minfrac}, uint64_t @var{maxfrac},@
					  uint64_t @var{andmask},@
					  uint64_t @var{ormask})
Return a random double precision number whose IEEE@tie{}754 structure (sign, exponent, fractional part) obeys the constraints given as parameters:
@itemize
@item@var{s}: possible sign. May be @code{fpngl_positive}, @code{fpngl_negative}, or @code{fpngl_whatever} if both positive and negative signs are allowed;
@item@var{minexp}: minimum exponent allowed. This is the biased value, which means you must add @math{1023} to the actual value. Possible values are in the domain
@math{[0,2047]};
@item@var{maxexp}: maximum exponent allowed. This is the biased value, which means you must add @math{1023} to the actual value. Possible values are in the domain
@math{[0,2047]};
@item@var{minfrac}: minimum fractional part expressed as a 52 bits unsigned integer
between @code{0x0000000000000000} and @code{0x000fffffffffffff};
@item@var{maxfrac}: maximum fractional part expressed as a 52 bits unsigned integer
between @code{0x0000000000000000} and @code{0x000fffffffffffff};
@item@var{andmask}: bitwise @code{AND} mask applied to the integer obtained by
concatenating the random sign, biased exponent, and fractional part. Should be
@code{fpngl_noand64}@footnote{The @code{fpngl_noand64} constant has value @code{0xffffffffffffffff}  and is defined in @file{fpnglib/constants64.h}.} if no mask is to be applied;
@item@var{ormask}: bitwise @code{OR} mask applied to the result of the bitwise AND.
Should be @code{fpngl_noor64}@footnote{The @code{fpngl_noor64} constant has value
@code{0x0000000000000000} and is defined in @file{fpnglib/constants64.h}.} if no mask
is needed.
@end itemize

Note that, for better performances, the consistency of the constraints are not tested. 
@end deftypefn

@node Drawing floats non-uniformly
@section Drawing floats non-uniformly
@c ----------------------------------

The FPNGlib library proposes a simple way to draw floating-point numbers from one of
the five classes presented in @ref{Drawing floats in a class} according to some discrete probability distribution. The user first defines the probability distribution for each of the classes in the order ``@code{zero, subnormal, normal, infinite, nan}'' with the function @code{fpngl_class_float64_new}; it is then possible to draw floats following that distribution with the function @code{fpngl_float64_distrib}. This functionality is just a facility offered around the more general method presented in @ref{Non-Uniform Distributions}.

@deftypefn {@file{fpnglib/float64.h}} fpngl_distribution_t* fpngl_class_float64_new@
           (fpngl_irng_t* @var{irng}, const double @var{P}[static 5])
Create an @code{fpngl_distribution_t} object representing the discrete probability distribution defined by the array @var{P} of at least 5 values:
@itemize
@item @code{P[0]}: probability of returning @math{\pm0.0};
@item @code{P[1]}: probability of returning a subnormal number;
@item @code{P[2]}: probability of returning a normal number;
@item @code{P[3]}: probability of returning @math{\pm\infty};
@item @code{P[4]}: probability of returning an @emph{NaN}.
@end itemize
The sum of the first five values in @var{P} must be equal to 1. Note that, inside the classes 1 and 2 (subnormal and normal numbers), the floats are still drawn uniformly at random.
@end deftypefn

@deftypefn {@file{fpnglib/float64.h}} double fpngl_float64_distrib@
           (fpngl_distribution_t* @var{fpd})
Return a floating-point number from one of the four classes ``zero, subnormal, normal, infinite, nan'' according to the probability distribution @var{fpd}.
@end deftypefn


@node IEEE 754 and the Floating-Point Unit
@chapter IEEE 754 and the Floating-Point Unit
@c ==========================================

This chapter describes the various constants, functions and macros provided by FPNGlib that do not directly contribute to the generation of random numbers. 

@section Constants
@c ---------------

Several constants related to the characteristics of the IEEE@tie{}754 floating-point
format are defined in files @file{fpnglib/constants32.h} ---for the single precision---
and @file{fpnglib/constants64.h} ---for the double precision.

@deftypevr {@file{fpnglib/constants32.h}} {const uint32_t} fpngl_emin32
@deftypevrx {@file{fpnglib/constants64.h}} {const uint32_t} fpngl_emin64
@deftypevrx {@file{fpnglib/constants32.h}} {const uint32_t} fpngl_emax32
@deftypevrx {@file{fpnglib/constants64.h}} {const uint32_t} fpngl_emax64
Smallest and largest unbiased exponents for single and double precision float.

@noindent @strong{Example}
@cartouche
@verbatiminclude snippets/exponent.c
@end cartouche
@noindent @strong{Output:}
@verbatim
Single precision exponent in [-126, 127]
Double precision exponent in [-1022, 1023]
@end verbatim
@end deftypevr

@deftypevr {@file{fpnglib/constants32.h}} {const uint32_t} fpngl_t32
@deftypevrx {@file{fpnglib/constants64.h}} {const uint32_t} fpngl_t64
Number of bits in the significand of a single or double precision float. The @dfn{significand} of a float corresponds to the fractional part together with the hidden bit before the binary point.

@noindent @strong{Example:}
@cartouche
@verbatiminclude snippets/significand.c
@end cartouche
@noindent @strong{Output:}
@verbatim
Number of bits with single precision: 24
Number of bits with double precision: 53
Number of digits with single precision: 7
Number of digits with double precision: 15
@end verbatim
@end deftypevr

@deftypevr {@file{fpnglib/constants32.h}} {const float} fpngl_mu32
@deftypevrx {@file{fpnglib/constants64.h}} {const double} fpngl_mu64
Smallest positive float. This is a subnormal number.

@noindent@b{Example:}
@cartouche
@verbatiminclude snippets/mu.c
@end cartouche
@noindent@b{Output:}
@verbatim
1
1
@end verbatim
@end deftypevr

@deftypevr {@file{fpnglib/constants32.h}} {const float} fpngl_lambda32
@deftypevrx {@file{fpnglib/constants64.h}} {const double} fpngl_lambda64
Smallest positive normal float.

@noindent@b{Example:}
@cartouche
@verbatiminclude snippets/lambda.c
@end cartouche
@noindent@b{Output:}
@verbatim
Single precision smallest positive normal: 1.17549e-38
Double precision smallest positive normal: 2.22507e-308
@end verbatim
@end deftypevr

@deftypevr {@file{fpnglib/constants32.h}} {const float} fpngl_u32
@deftypevrx {@file{fpnglib/constants64.h}} {const double} fpngl_u64
@dfn{Unit roundoff}, which is half the distance between @code{1.0} and the next floating-point number.

@noindent@b{Example:}
@cartouche
@verbatiminclude snippets/unitroundoff.c
@end cartouche
@noindent@b{Output:}
@verbatim
Single precision unit roundoff: 5.96046e-08
Double precision unit roundoff: 1.11022e-16
@end verbatim
@end deftypevr

@deftypevr {@file{fpnglib/constants32.h}} {const float} fpngl_max32
@deftypevrx {@file{fpnglib/constants64.h}} {const double} fpngl_max64
Largest positive finite float.

@noindent@b{Example:}
@cartouche
@verbatiminclude snippets/max.c
@end cartouche
@noindent@b{Output:}
@verbatim
Single precision largest float: 3.40282e+38
Double precision largest float: 1.79769e+308
@end verbatim
@end deftypevr

@deftypevr {@file{fpnglib/constants32.h}} {const float} fpngl_NaN32
@deftypevrx {@file{fpnglib/constants64.h}} {const double} fpngl_NaN64
Return a @emph{Not a Number}.

@noindent@b{Example:}
@cartouche
@verbatiminclude snippets/nan.c
@end cartouche
@noindent@b{Output:}
@verbatim
Single precision NaN: nan
Double precision NaN: nan
@end verbatim
@end deftypevr

@deftypevr {@file{fpnglib/constants32.h}} {const float} fpngl_infinity32
@deftypevrx {@file{fpnglib/constants64.h}} {const double} fpngl_infinity64
Infinity value.

@noindent@b{Example:}
@cartouche
@verbatiminclude snippets/inf.c
@end cartouche
@noindent@b{Output:}
@verbatim
Single precision infinity: inf
Double precision infinity: inf
@end verbatim
@end deftypevr

@deftypevr {@file{fpnglib/constants64.h}} {const uint64_t} fpngl_minfrac64
@deftypevrx {@file{fpnglib/constants64.h}} {constant uint64_t} fpngl_maxfrac64
Minimum and maximum value for the fractional part of a 64-bit double precision floating-point number. These constants are mainly used when calling @code{fpngl_float64} to draw floats with some properties.

@noindent@b{Example:}
@cartouche
@verbatiminclude snippets/minmaxfrac.c
@end cartouche
@noindent@b{Output:}
@verbatim
minfrac64: 0
maxfrac64: fffffffffffff
@end verbatim
@end deftypevr

@deftypevr {@file{fpnglib/constants64.h}} {const uint64_t} fpngl_noand64
@deftypevrx {@file{fpnglib/constants64.h}} {const uint64_t} fpngl_noor64
Masks to use with the function @code{fpng_float64} when no @emph{and} mask
(resp.@tie{}no @emph{or} mask) is needed for the fractional part of the floats
constructed.

@noindent@b{Example:}
@cartouche
@verbatiminclude snippets/noandor.c
@end cartouche
@noindent@b{Output:}
@verbatim
noand64 mask: ffffffffffffffff
noor64 mask: 0
@end verbatim
@end deftypevr

@section Utility Functions
@c -----------------------

FPNGlib defines functions that can aid in computing the floating-point numbers an application requires. 

@deftypefn {@file{fpnglib/float64.h}} double fpngl_nextafter64 (double @var{v}, uint64_t @var{n})
Return a double precision number that is @var{n} floating-point numbers @emph{after}
@var{v} on the real line.

The value of @var{n} must be smaller or equal to @code{0xffe0000000000000}. The function will abort if @var{n} is greater than that @b{and} the library has been compiled with @option{--enable-debug=yes}. Otherwise, the behavior is undefined.

If @var{v} is an NaN, the function returns the same NaN. Otherwise, it returns either a finite float or a positive infinite, depending on the value of @var{n} and the distance of @var{v} to the maximum representable double precision float.

@noindent@b{Example:}
@cartouche
@verbatiminclude snippets/nextafter64.c
@end cartouche
The output is @code{1} since there are @math{2^{52}} floats from @code{1.0} to @code{2.0} in double precision.
@end deftypefn


@deftypefn {@file{fpnglib/float64.h}} double fpngl_previous64 (double @var{v}, uint64_t @var{n})
Return a double precision number that is @var{n} floating-point numbers @emph{before}
@var{v} on the real line.

The value of @var{n} must be smaller or equal to @code{0xffe0000000000000}. The function will abort if @var{n} is greater than that @b{and} the library has been compiled with @option{--enable-debug=yes}. Otherwise, the behavior is undefined.

If @var{v} is an NaN, the function returns the same NaN. Otherwise, it returns either a finite float or a positive infinite, depending on the value of @var{n} and the distance of @var{v} to the maximum representable double precision float.

@noindent@b{Example:}
@cartouche
@verbatiminclude snippets/previous64.c
@end cartouche
The output is @code{1} since the smallest positive double precision float is separated from the largest negative float by @code{0}.
@end deftypefn

@deftypefn {@file{fpnglib/float64.h}} uint64_t fpngl_distance_float64 @
           (double @var{a}, double @var{b})
Return the number of floats (bounds included) from value @var{a} to value @var{b}. Return
@code{1} if @code{@var{a}==@var{b}} and @code{0} if either @var{a} or @var{b} are not
finite floats (infinities or NaNs).

The function is only defined for @code{@var{a} <= @var{b}}.
@end deftypefn

@deftypefn {@file{fpnglib/float64.h}} uint64_t fpngl_signed_distance_float64 @
           (double @var{a}, double @var{b})
Return the number of floats (bounds included) from value @var{a} to value @var{b}. Return
@code{1} if @code{@var{a}==@var{b}} and @code{0} if either @var{a} or @var{b} are not
finite floats (infinities or NaNs). Return a negative value if @code{@var{a} < @var{b}}.
@end deftypefn

@section Manipulating the FPU 
@c ------------------------


@node Extending the Library
@chapter Extending the Library
@c ===========================
The library is written with an object-oriented style that should make it easy to extend.

@float Figure,fig:classes
@image{fpnglib-figures/classes,6in,}
@caption{The ``classes'' of FPNGlib}
@end float

Functions with ``@code{_internal}'' in their name are for internal use in the library and should not be used outside of its realm.
@cindex @code{_internal} suffix

@section Debugging facilities
@c --------------------------

FPNGlib offers facilities to debug itself. There are in particular some macros that can be used to display messages to the standard error ouput @code{stderr}, provided the library was configured with the option @option{--enable-debug=yes} (the default) or @option{--enable-debug=info} for some macros.

@deffn {@file{fpnglib/debug.h}} FPNGL_DEBUG (...)
Uses @code{fprintf} to output its arguments to @code{stderr} if the macro @code{NDEBUG}
is defined to @code{1}. Otherwise, it does nothing.

The macro flushes the output buffer with @code{fflush} after each call.

@noindent@b{Example:}
@cartouche
@verbatiminclude snippets/debug.c
@end cartouche
@end deffn

@deffn {@file{fpnglib/debug.h}} FPNGL_WARNING (...)
Displays a warning message to @code{stderr} if the library was configured with either
@option{--enable-debug=yes} or @option{--enable-debug=info}.

The macro flushes the output buffer with @code{fflush} after each call.

@noindent@b{Example:}
@cartouche
@verbatiminclude snippets/warning.c
@end cartouche
@end deffn

@section Adding new IRNGs
@c ----------------------

@deftypefn {Library Function} fpngl_irng32_t* fpngl_irng32_new @
           (uint32_t @var{seed},
            const char* @var{name},
						uint32_t @var{min}, uint32_t @var{max},
						void* @var{state},
						void* (*@var{copy_state})(void*),
						uint32_t (*@var{next32})(void*),
						uint64_t (*@var{next64})(void*),
						uint32_t (*@var{nextk})(void*, uint32_t),
						void (*@var{next_array32})(void *, uint32_t *, uint32_t),
  					void (*@var{next_array64})(void *, uint64_t *, uint32_t),
						void (*@var{delete})(void*))
@c TODO            
@end deftypefn   

@section Miscellaneous Supporting Code
@c -----------------------------------

@c Describe uistack

@node Function Index
@chapter Function Index
@c ====================
@printindex fn

@node Type Index
@chapter Type Index
@c ================
@printindex tp

@node Concept Index
@chapter Concept Index
@c ===================
@printindex cp

@bye

@c Local Variables:
@c mode: texinfo
@c TeX-master: t
@c End:
