\input texinfo @c -*-texinfo-*-
@c %**start of header
@c @afourpaper
@setfilename fpnglib.info
@include version.texi
@settitle The FPNGlib Library
@finalout
@c -@setchapternewpage odd
@c %**end of header

@titlepage
@title The FPNGlib Manual
@subtitle Version @value{VERSION}
@subtitle Updated @value{UPDATED}
@author Fr@'ed@'eric Goualard
LS2N UMR CNRS 6004, University of Nantes, France

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2019,2020 University of Nantes, France

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Foundation.
@end titlepage

@shortcontents

@contents

@node What is FPNGlib?
@chapter What is FPNGlib?
@c ======================

FPNGlib is a C library that offers pseudo-random generators in a unified framework. As the name implies, its strong point is the availability of many IEEE@tie{}754@footnote{@i{IEEE Standard for Floating-Point Arithmetic. IEEE STD 754-2008}. IEEE Computer Society, 2008.} floating-point random number generators, with the possibility to control the kind of floating-point number generated (e.g., the amount of subnormal vs. normal) and their properties (e.g., probability of having a least significant bit of the fractional part to be @math{1})

Even though it is entirely written in ISO Standard C99, FPNGlib is, at present, only supported on UNIX-like systems (GNU/Linux and Mac@tie{}OS@tie{}X are the only two tested environments) due to the tools used for its configuration, compilation and deployment (@emph{autotools}).
@cindex Supported platforms

More information about the FPNGlib library can be found at the project homepage,
@uref{https://gitlab.univ-nantes.fr/goualard-f/fpnglib}.


This manual assumes a basic knowledge of the IEEE~754 standard and refers to the internal representation of floating-point numbers in several places. Readers unfamiliar with it may find beneficial to at least read the @url{https://en.wikipedia.org/wiki/IEEE_754,Wikipedia entry} for the standard first.

The FPNGlib library contains code from third parties, specifically:
@itemize @bullet
@item @url{https://maths-people.anu.edu.au/~brent/random.html,xorgens 3.06} by Richard Brent, licenced under the @url{http://www.gnu.org/copyleft/gpl.html,GNU General Public License};
@item Both 64 bits and 32 bits versions of the @url{http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html,Mersenne twister}, by Takuji Nishimura and Makoto Matsumoto, whose licenses can be found in files @file{src/mt19937-64.c} and @file{src/mt19937ar.c}.
@end itemize

Additionally, the implementation of the Walker/Vose algorithm in @code{src/walker_vose.c} is mostly a reimplementation in C of the Java version by Keith Schwarz (@url{https://www.keithschwarz.com/interesting/code/?dir=alias-method}). Some code is also directly taken from the @url{https://www.gnu.org/software/gsl/,GNU GSL 2.6} implementation of the same.

@unnumberedsec A Word of Caution
@cindex Cryptographic use
FPNGlib does not contain any true random generator as its focus is on reproducibility for applications such as Monte-Carlo algorithms and the like. As a consequence, it shall not be used for cryptographic applications.

@unnumberedsec Reporting a Bug
@cindex Bug report

Questions and bug reports shall be directly submitted on the @url{https://gitlab.univ-nantes.fr/goualard-f/fpnglib/issues,GitLab platform} for the project.

@node Getting Started with FPNGlib
@chapter Getting Started with FPNGlib
@c ==================================

This chapter describes the very first steps with FPNGlib, from the retrieval of the archive for the library to the first program you will write to test its potential. If you are accustomed to work with autotools-based software, feel free to proceed directly to @ref{An Introduction to FPNGlib}.

@section Installation
@c ------------------
The FPNGlib library uses the @emph{autotools} (@url{https://www.gnu.org/software/autoconf/,autoconf}, @url{https://www.gnu.org/software/automake/,automake}, @url{https://www.gnu.org/software/libtool/,libtool}) for configuration, compilation, and deployment. However, these tools do not need to be present on your computer as long as you do not modify the configuration files (@file{configure.ac} and the various @file{Makefile.am} files).

The library is entirely written in the ISO/IEC 9899:1999 C language. Therefore, its compilation requires a sufficiently recent C compiler such as any GNU C Compiler v.@tie{}4.5 or higher.

In order to test the library, you will need to install @command{check} v. 0.11.0 or higher (@url{https://libcheck.github.io/check/}) beforehand. If your compiler does not support
the macro @code{__VA_OPT__}, some tests will not be performed. That macro should be
available in GCC version 8 and above, and in Clang version 6 and above.

Before compiling the library, you need to configure it. It is done by calling the command @command{./configure} in the root directory of FPNGlib. The command accepts many options, among them:

@itemize @w{}
@item @option{--help}: displays a list of all the options available;
@item @option{--prefix=@var{<path to install into>}}: gives the path to install the code into. The header files will go into an @file{include/} subdirectory, while the library will go into a @file{lib/} subdirectory;
@item @option{--enable-debug=@var{[yes/info/profile/no]}}: define whether the code should be compiled with debugging information and assertion support. The default is @samp{yes}.
@end itemize
There are many other options, shared by all autotools-based applications. Use @command{./configure --help} to get the complete list.

Once the configuration is complete, you may call @command{make} in the root directory of the distribution for FPNGlib to compile the library.

After having compiled the library, you should test it, in order to ensure that everything is ok. This is done by calling @command{make check}. If no error is detected, you may proceed to the installation phase.

The library should be installed before being used. However, if you want to get a taste of it beforehand, you may modify and execute the examples in the sub-directory @command{examples/}, even before the installation. Calling @command{make} in this directory will recompile the necessary files.

The installation is done by calling @command{make install} from the top directory of the distribution. By default, the library is installed into @file{/usr/local}.

@page
@node An Introduction to FPNGlib
@section An Introduction to FPNGlib
@c --------------------------------
FPNGlib offers generators for random integers and random IEEE 754 floating-point numbers. We will first see how to obtain random integers in @ref{Generating Random Integers} and @ref{Generating Random Integers in a Domain}, and then random floats in @ref{Generating Random Floating-Point Numbers} and @ref{Generating a random float with some properties}.

@node Generating Random Integers
@subsection Generating Random Integers
@c ...................................
Our very first program using FPNGlib simply draws one integer at random:

@cartouche
@verbatiminclude snippets/isimple.c
@end cartouche

Assuming you have installed FPNGlib locally in some directory @file{$HOME/local} by configuring it with the command @samp{./configure --prefix=$HOME/local}, you may compile the example above by calling @command{gcc} as such:

@example
gcc -I$HOME/local/include -L$HOME/local/lib \
      -o simple simple.c -lfpnglib
@end example
@cindex Compiling with libfpnglib.so

Of course, if both the @emph{include} directory and the @emph{lib} directory paths appear in the relevant environment variables (@env{C_INCLUDE_PATH} and @env{LD_LIBRARY_PATH}, respectively), you may dispense with the @code{-I} and @code{-L} directives entirely.
Alternatively, as long as you work on the example file provided in the distribution of the library, you may simply call @command{make isimple} to compile it.

The output of this program should be:
@verbatim
3340206418
11203470090111516746
@end verbatim

In the example above, we use the 32 bits version of the Mersenne Twister MT19937@footnote{@url{http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/earticles.html,@cite{Mersenne Twister: A 623-dimensionally equidistributed uniform pseudorandom number generator, M. Matsumoto and T. Nishimura. ACM Trans. on Modeling and Computer Simulation, 8(1), 1998.}}}, but FPNGlib also offers the 64 bits version, declared in @file{fpnglib/mt19937-64.h}.

Random integers come in two sizes: 32 bits and 64 bits. As exemplified in the example above, both sizes may be created by 32 bits generators as well as 64 bits ones: A 32 bits generator will combine two outputs to return a 64 bits integer; on the other hand, a 64 bits generator will usually split its output into two 32 bits integers and return one of them to produce a 32 bits integer.

All Random Number Generators (@dfn{RNG}) may be initialized by a single integer, the @emph{seed}. In addition, some may be initialized by other means, mostly vectors of integers. It is the case with the Mersenne Twister MT19937, of which an instance may be created with the @code{fpngl_mt19937v32_by_array} function instead of @code{fpngl_mt19937v32}. Both functions return a pointer to an object of the opaque type @code{fpngl_irng32_t}. Since the implementation of that type is not public, all object of the type must be manipulated through pointers only. This is the rule for most types in FPNGlib.

By calling the function @code{fpngl_irng32_next32}, we compute the next 32 bits
integer. When calling the function @code{fpngl_irng32_next64}, the next two 32 bits integer are computed and combined to produce one 64 bits integer.

The call to @code{fpngl_mt19937v32} allocates some memory from the heap to represent the internal structure of the MT19937 RNG. We need to call @code{fpngl_irng32_delete} to reclaim that memory as soon as the RNG is no longer used.

@node Generating Random Integers in a Domain
@subsection Generating Random Integers in a Domain
@c ...............................................
A 32 bits Integer RNG (@dfn{IRNG}, for short) will usually draw an integer in the domain @math{[0,2^{32}-1]} or in some other smaller but still impractically large domain. More often than not, simulations require drawing integers in some precise domain, say @math{[1,6]} to simulate a dice, for example. For such an application, many sources still suggest to draw an integer in the full domain of the RNG and then use the modulo to restrict the output to the correct domain:
@cartouche
@anchor{biased_dice_c}
@verbatiminclude snippets/biased_dice.c
@end cartouche

However, since @math{2^{32} = 6\times 715827882 + 4}, there are @math{715827883} ways to produce the numbers @math{1} to @math{4}, and only @math{715827882} ways to produce the numbers @math{5} and @math{6}, which introduces a @math{1.397\times 10^{-7}}% bias. A very small bias indeed, but one that could become significant if one used a different RNG, such as a @emph{Linear Congruential Generator}@footnote{@cite{@url{https://en.wikipedia.org/wiki/Linear_congruential_generator}}.} (@dfn{LCG}) with a congruence much smaller than @math{2^{32}}.

With FPNGLlib, the proper way to generate a random integer in the domain @math{[0,k]}, is to use the @code{fpngl_ubound32} or @code{fpngl_ubound64} functions available in @file{fpnglib/irange.h}, depending on the type of RNG used:

@cartouche
@verbatiminclude snippets/dice.c
@end cartouche
Remember that the function @code{fpngl_mt19937v32} creates a 32 bits RNG with type @code{fpngl_irng32_t}. The @code{fpngl_ubound32} function computes a random integer in @math{[0,k-1]}, given @math{k} as its second argument. However, it must accept to do so with both a 32 bits RNG and a 64 bits RNG. We therefore need to encapsulate the actual 32 bits RNG into a ``generic'' RNG of type @code{fpngl_irng_t} with the function @code{fpngl_irng_new32}. The @code{irng} variable owns the 32 bits RNG it encapsulates and is responsible for its deletion, which will be done when we call @code{fpngl_irng_delete} instead of @code{fpngl_irng32_delete}. 

The @code{fpngl_ubound32} function uses the modification by O'Neill@footnote{@i{Efficiently Generating a Number in a Range}, Melissa E. O'Neil, @url{https://www.pcg-random.org/posts/bounded-rands.html}, 2018.} of Lemire's algorithm@footnote{@i{Fast Random Integer Generation in an Interval}, Daniel Lemire, ACM TOMACS 29(1), 2019.} to draw integers in an interval. The @code{fpngl_ubound64} uses the same algorithm, provided a 128 bits integer type
is available on the platform used. Otherwise, it uses slower methods presented by O'Neill at @url{https://www.pcg-random.org/posts/bounded-rands.html}.

To draw integers from a domain @math{[a,b]} instead of @math{[0,k]}, one can use the functions @code{fpngl_range32} and @code{fpngl_range64}. 

@node Generating Random Floating-Point Numbers
@subsection Generating Random Floating-Point Numbers
@c .................................................
One of the strong points of FPNGlib is the generation of IEEE@tie{}754 floating-point numbers@footnote{@i{IEEE Standard for Floating-Point Arithmetic. IEEE STD 754-2008}. IEEE Computer Society, 2008.} (@dfn{floats}, for short). It offers many methods to draw floats in different domains and with various properties.

In the following example, we use the same RNG as the one used for @code{java.util.Random} in Java@tie{}8 to compute one double precision floating-point number in @math{[0,1)}:

@cartouche
@verbatiminclude snippets/fsimple.c
@end cartouche

The output expressed using the C99 hexadecimal format@footnote{See Section 6.4.4.2 of @i{ISO/IEC 9899:1999}.} is ``@code{0x1.314880e9bdp-10}.''

Floating-point number generators (@dfn{FRNG}s, for short) are either of the type @code{fpngl_frng32_t} when they produce single
precision floats, or @code{fpngl_frng64_t} for double precision. In the same way as for integer generators,
floats generators can only be manipulated through pointers to objects of these types. All generators of either type must implement the same functionalities. In particular, as shown in @ref{exa:mcpi}, double precision generators must implement the following calls:
@itemize
@item @code{fpgnl_frng64_name()}: returns a constant string corresponding to the name of
      the generator;
@item @code{fpngl_fnrg64_nextf64()}: returns the next double precision random number;
@item @code{fpngl_frng64_delete()}: reclaims the memory used to represent the generator.
@end itemize
As a consequence, it is possible to write functions requiring random floats independently of the FRNG actually used, and to pass it as a parameter (see, e.g., @code{mcpi} in @ref{exa:mcpi}).

Note, however, that FRNGs are not bound to return floats in any prescribed domain: some may return values in ``@math{[0,1)},'' some in ``@math{(0,1)},'' and some others in any other domain. It is then the responsibility of the programmer to choose FRNGs according to the domains they are interested into.

A classical way to implement FRNGs is to rely on an integer RNG and divide its output by
some integer constant, usually the largest possible integer the RNG can produce or the next integer above. This is what we do to create @code{frng0} in @ref{exa:mcpi}. Firstly, we create an IRNG based on the 32 bits version of the Mersenne Twister MT19937, then we create an FRNG by using the @code{fpngl_bydivision_new} constructor. That constructor takes three parameters:
@enumerate
@item A name for the newly created FRNG (``@code{FMT19937v32},'' in @ref{exa:mcpi});
@item An IRNG of the type @code{fpngl_irng_t};
@item A divisor by which each random integer should be divided (here, we choose to divide
      by the smallest integer strictly larger than the largest random number that our IRNG can produce, therefore creating a FRNG returning values in @math{[0,1)}@footnote{As a side note, the open bound is guaranteed only if the divisor is smaller than @math{2^{53}}, which is the case here since we use a 32 bits IRNG.}).
@end enumerate

Note that, as is always the case in FPNGlib, the FRNG @code{frng0} created from the IRNG @code{irng32} ``owns'' it and is, therefore, responsible for its destruction. This is why we do not call @code{fpngl_irng_delete} at the end of the program: the call @code{fpngl_frng64_delete(frng0)} is sufficient to reclaim both the memory allocated to represent @code{frng0} and @code{irng32}.

The FRNG created with @code{fpngl_drand48bsd} also relies on the division of the result
of a Linear Congruential Generator by a constant integer. The result is a floating-point number in @math{[0,1)} with 48 bits of entropy only.

@float Example,exa:mcpi
@cartouche
@verbatiminclude snippets/mcpi.c
@end cartouche
@caption{Computing an approximation to @math{\pi} with a Monte Carlo method.}
@end float

@node Generating a random float with some properties
@subsection Generating a random float with some properties
@c .......................................................

For some applications, we are interested in drawing floating-point numbers with some
definite properties only. That might be:
@itemize
@item Only subnormal floats;
@item Only normal floats;
@item Subnormal and normal floats in some precision proportion; 
@item Only positive floats with the exponent in some domain and the fractional part in
another domain;
@item @dots{}
@end itemize

FPNGlib is particularly well suited for this kind of applications as it offers many ways to define the properties the floats drawn should meet.

For example, if only random double precision subnormal floats are required, one can use the @code{fpngl_denormal64} function. For random normal floats, the @code{fpngl_normal64} function can be used:

@cartouche
@verbatiminclude snippets/subnormal.c
@end cartouche

Both functions require an integer RNG, as the subnormal and normal random floats are constructed from their exponent and fractional part fields.

FPNGlib considers five classes of floats:
@itemize
@item @math{\pm0};
@item Subnormal;
@item Normal;
@item @math{\pm\infty};
@item @emph{Not a Number}.
@end itemize
There are generator functions for each of theses classes. In addition, using the @code{fpngl_class_float64_new} function, it is easy to draw floats from these five classes with different probabilities attached to each:
@cartouche
@verbatiminclude snippets/distrib.c
@end cartouche
This program displays 10 floats, with probabilities 12.5% that they are equal to @math{\pm0}, 25% that they are subnormal, 50% that they are normal, and  12.5% that they are infinite.

Note that the object of type @code{fpngl_distribution_t} owns the RNG @var{irng} and is responsible for its destruction. This is why we only call @code{fpngl_distribution_delete} to delete the @var{dist} object, and not @code{fpngl_irng_delete} on @var{irng}.

A more flexible way to draw floats from a specific set is to put constraints on the acceptable sign, exponent and fractional part with the @code{fpngl_float64} function. The following program, for example, will draw 10 double precision floats in @code{[2,4)}:
@cartouche
@verbatiminclude snippets/float64.c
@end cartouche
The first parameter of @code{fpngl_float64} is an integer RNG, which is used to draw the integers defining the sign, exponent and fractional part of the float returned. The second parameter indicates what is the expected sign of the float drawn; It can be one of:
@itemize
@item @code{fpngl_positive} (for drawing only positive floats);
@item @code{fpngl_negative} (for drawing only negative floats);
@item @code{fpngl_whatever} (for either positive or negative floats, with an equiprobability of both).
@end itemize
The third and fourth parameters establish bounds on the @emph{biased} exponent@footnote{The @emph{biased} exponent @math{e} for double precision floats takes its value in @math{[0,2047]}, the actual exponent @math{E} being equal to @math{e-1023}.}. The fifth and sixth parameters establish bounds on the possible values of the fractional part, with @code{fpngl_minfrac64} being the smallest possible value, equal to @code{0x0000000000000}, and @code{fpngl_maxfrac64} being the largest possible value, equal to @code{0xfffffffffffff}. Lastly, the seventh and eighth parameters are masks that are ultimately applied to the fractional part: the seventh parameter is ``@i{and}ed'' with the fractional part and the eighth parameter is ``@i{or}ed'' with that resulting value.

In the example above, we are asking for floats with a positive sign, an exponent of @code{1} (@math{1024} minus the bias of @math{1023}) and a fractional part between  @code{0x0000000000000} and @code{0xfffffffffffff}, that is ---in binary--- floats from @math{+1.0\times2^1} to @math{+1.111111111111111111111111111111111111111111111111111\times2^1}, or ---in decimal---, from @math{2.0} to @math{4.0-2^{-51}}.

@node General Organization of the Library
@chapter General Organization of the Library
@c =========================================

In FPNGlib, all public constants, variables, types, and functions are prefixed with @samp{fpngl_} to make them stand apart in larger programs and avoid name collisions.
@cindex Prefix
 All header files from FPNGlib are in the directory @file{fpnglib/}.
 
All RNGs have types whose name is formed according to the same principle: first the prefix @samp{fpngl_}, then the type of the RNG (@samp{irng} for
an RNG generating integers, and @samp{frng} for an RNG generating floating-point
numbers) followed by the size of the values returned (@samp{32} for 32 bits integers and
single precision floating-point numbers, and @samp{64} for 64 bits integers and
double precision floating-point numbers), and finally the postfix @samp{_t} to mark the name as a type. A slight exception to this scheme is the type @code{fpngl_irng_t} that can wrap 32 bits as well as 64 bits integer RNGs.
@cindex Type name formation

All in all, there are at present five Random Number Generator types in FPNGlib:
@itemize
@item@w{}@code{fpngl_irng32_t}. RNG generating 32 bits integers natively;
@item@w{}@code{fpngl_irng64_t}. RNG generating 64 bits integers natively;
@item@w{}@code{fpngl_irng_t}. Wrapper for a RNG generating natively either 32 bits or 64 bits integers;
@item@w{}@code{fpngl_frng32_t}. RNG generating single precision (@code{float}) IEEE@tie{}754 floating-point numbers; 
@item@w{}@code{fpngl_frng64_t}. RNG generating double precision (@code{double}) IEEE@tie{}754 floating-point numbers.
@end itemize
Note that both 32 bits and 64 bits integer RNGs can generate 32 bits as well as 64 bits integers with, respectively, the functions @code{fpngl_irng32_next64} and @code{fpngl_irn64_next32}.

The complete state of all the RNGs is entirely contained in an object of one of the abovementioned types. There are no global variables, which means that the user may define and use several RNGs, even of the same type, without any risk of interferences between them.

@node Integer Random Generators
@chapter Integer Random Generators
@c ===============================

In this chapter, we present the Random Number Generator capable of producing 32 bits as well as 64 bits integers. They all follow a nuiform distribution. Refer to @ref{Non-Uniform Distributions} for other distributions.

Random Number Generators that produce integers must all provide the same services independently of the size of the integers they ``natively'' produce:
@itemize
@item Compute a 32 bits integer;
@item Compute a 64 bits integer;
@item Compute @math{k} random bits, with @math{k} being smaller than the
      size of the integers produced natively by the RNG;
@item Compute of an array of 32 bits integer;
@item Compute of an array of 64 bits integer;
@item Return the seed used to initialize the RNG;
@item Return the minimum integer the RNG can produce;
@item Return the maximum integer the RNG can produce.
@end itemize

In addition, an RNG must possess a function to release the resources acquired upon
construction of an instance. Each RNG type has its own constructor (@xref{Integer RNGs available}).

In the following, we describe the functions providing these services for RNGs of the type @code{fpngl_irng32_t}, @code{fpngl_irng64_t}, as well as for the wrapper type @code{fpngl_irng_t}. The services specific to this last type are described in @ref{Unsized RNGs}.

@deftypefn {Library Function} void fpngl_irng32_delete (fpngl_irng32_t* @var{rng})
@deftypefnx {Library Function} void fpngl_irng64_delete (fpngl_irng64_t* @var{rng})
@deftypefnx {Library Function} void fpngl_irng_delete (fpngl_irng_t* @var{rng})
Releases the resources acquired upon the construction of the RNg @var{rng}.
@end deftypefn

@deftypefn {Library Function} uint32_t fpngl_irng32_next32 (fpngl_irng32_t* @var{rng})
@deftypefnx {Library Function} uint32_t fpngl_irng64_next32 (fpngl_irng64_t* @var{rng})
@deftypefnx {Library Function} uint32_t fpngl_irng_next32 (fpngl_irng_t* @var{rng})
Return the next 32 bits random integer.
A 64 bits RNG will usually compute a 64 bits integer
and return the lower or higher 32 bits.
@end deftypefn

@deftypefn {Library Function} uint64_t fpngl_irng32_next64 (fpngl_irng32_t* @var{rng})
@deftypefnx {Library Function} uint64_t fpngl_irng64_next64 (fpngl_irng64_t* @var{rng})
@deftypefnx {Library Function} uint64_t fpngl_irng_next64 (fpngl_irng_t* @var{rng})
Return the next 64 bits random integer. A 32 bits RNG will be called twice
to create a 64 bits integer.
@end deftypefn

@deftypefn {Library Function} uint32_t fpngl_irng32_nextk @
           (fpngl_irng32_t* @var{rng}, uint32_t @var{k})
@deftypefnx {Library Function} uint64_t fpngl_irng64_nextk @
            (fpngl_irng64_t* @var{rng}, uint32_t @var{k})
@deftypefnx {Library Function} uint64_t fpngl_irng_nextk @
            (fpngl_irng_t* @var{rng}, uint32_t @var{k})
Return the next @var{k} random bits. The maximum value of @var{k} depends on the
type of RNG:
@itemize
@item @var{k}@math{\in[0,32]} for a 32 bits RNG;
@item @var{k}@math{\in[0,64]} for a 64 bits RNG;
@item @var{k}@math{\in[0,64]} for a wrapped RNG of type @code{fpngl_irng_t}.
@end itemize

Note that @var{k} may be greater than 32 for a 32 bits RNG when it is wrapped
in an RNG of type @code{fpngl_irng_t}. In that case, the RNG is called twice and
the two outputs are aggregated to form the result.
@end deftypefn

@deftypefn {Library Function} void fpngl_irng32_array32 @
           (fpngl_irng32_t* @var{rng}, uint32_t* @var{T}, uint32_t @var{n})
@deftypefnx {Library Function} void fpngl_irng64_array32 @
           (fpngl_irng64_t* @var{rng}, uint32_t* @var{T}, uint32_t @var{n})
@deftypefnx {Library Function} void fpngl_irng_array32 @
           (fpngl_irng_t* @var{rng}, uint32_t* @var{T}, uint32_t @var{n})
Fill the array @var{T} with @var{n} 32 bits random integers. The array @var{T} must
have been allocated to the correct size before the call.

The speed-up obtained with this function, compared with calling @var{n} times a
@code{*_next32} function depends on the RNG used. For most implementations, a 64 bits
RNG will be called at most @math{@var{n}/2} times and each 64 bits integer split into
two 32 bits integers to fill adjacent positions in the array.
@end deftypefn

@deftypefn {Library Function} void fpngl_irng32_array64 @
           (fpngl_irng32_t* @var{rng}, uint64_t* @var{T}, uint32_t @var{n})
@deftypefnx {Library Function} void fpngl_irng64_array64 @
           (fpngl_irng64_t* @var{rng}, uint64_t* @var{T}, uint32_t @var{n})
@deftypefnx {Library Function} void fpngl_irng_array64 @
           (fpngl_irng_t* @var{rng}, uint64_t* @var{T}, uint32_t @var{n})
Fill the array @var{T} with @var{n} 64 bits random integers. The array @var{T} must
have been allocated to the correct size before the call.

The speed-up obtained with this function, compared with calling @var{n} times a
@code{*_next64} function depends on the RNG used. For most implementations, a 32 bits
RNG will be called @math{2@var{n}} times.
@end deftypefn

@deftypefn {Library Function} uint32_t fpngl_irng32_seed (fpngl_irng32_t* @var{rng})
@deftypefnx {Library Function} uint64_t fpngl_irng64_seed (fpngl_irng64_t* @var{rng})
@deftypefnx {Library Function} uint64_t fpngl_irng32_seed (fpngl_irng_t* @var{rng})
Return the value used to initialize the RNG.
@end deftypefn

@deftypefn {Library Function} {const char*} fpngl_irng32_name @
           (fpngl_irng32_t* @var{rng})
@deftypefnx {Library Function} {const char*} fpngl_irng64_name @
           (fpngl_irng64_t* @var{rng})
@deftypefnx {Library Function} {const char*} fpngl_irng_name @
           (fpngl_irng_t* @var{rng})
Return a pointer to the string representing the name of the RNG. Refer to each constructor in @ref{Integer RNGs available} to know the possible values.
@end deftypefn

@deftypefn {Library Function} uint32_t fpngl_irng32_min @
           (fpngl_irng32_t* @var{rng})
@deftypefnx {Library Function} uint64_t fpngl_irng64_min @
           (fpngl_irng64_t* @var{rng})
@deftypefnx {Library Function} uint64_t fpngl_irng_min @
           (fpngl_irng_t* @var{rng})
Return the smallest integer that can be drawn with the RNG.
@end deftypefn

@deftypefn {Library Function} uint32_t fpngl_irng32_max @
           (fpngl_irng32_t* @var{rng})
@deftypefnx {Library Function} uint64_t fpngl_irng64_max @
           (fpngl_irng64_t* @var{rng})
@deftypefnx {Library Function} uint64_t fpngl_irng_max @
           (fpngl_irng_t* @var{rng})
Return the largest integer that can be drawn with the RNG.
@end deftypefn

@deftypefn {Library Function} bool fpngl_is_irng32 (fpngl_irng_t* @var{rng})
@deftypefnx {Library Function} bool fpngl_is_irng64 (fpngl_irng_t* @var{rng})
Return @code{true} if the wrapped RNG is, respectively, of the type
@code{fpngl_irng32_t} or @code{fpngl_irng64_t}.
@end deftypefn

@node Unsized RNGs
@section Unsized RNGs
@c ----------------------
Since both 32 bits and 64 bits RNGs can produce 32 bits as well as 64 bits integers, users may be tempted to write programs that use an RNG, irrespective of its type. The @code{fpngl_irng_t} type serves as a wrapper around 32 bits and 64 bits RNGs to abstract their real limitations. An object of that type is constructed from an actual RNG of type @code{fpngl_irng32_t} or @code{fpngl_irng64_t} with, respectively, the functions @code{fpngl_irng_new32} and @code{fpngl_irng_new64}:
@cartouche
@verbatiminclude snippets/irng.c
@end cartouche
Note that the new RNG constructed ``owns'' the RNG passed as a parameter to @code{fpngl_irng_new32} or @code{fpngl_irng_new64} constructor, and is responsible for its proper disposal. The release of resources is then done with @code{fpngl_irng_delete} only.

@deftypefn {Library Function} fpngl_irng_t* fpngl_irng_new32 @
           (fpngl_irng32_t* @var{irng32})
@deftypefnx {Library Function} fpngl_irng_t* fpngl_irng_new64 @
            (fpngl_irng64_t* @var{irng64})
Wrap an 32 bits or 64 bits RNG into an @code{fpngl_irng_t} object. The new object
is responsible for the destruction of the RNG passed as a parameter. Consequently,
@var{irng32} (resp.@tie{}@var{irng64}) should be never be deleted with @code{fpngl_irng32_delete} (resp.@tie{}@code{fpngl_irng64_delete}) afterwards.
@end deftypefn

There is also a function to draw an integer of the size supported natively by the
wrapped RNG:

@deftypefn {Library Function} uint64_t fpngl_irng_next (fpngl_irng_t* @var{rng})
This function is unique to the @code{fpngl_irng_t} type. If the RNG wrapped is of type @code{fpngl_irng64_t}, it behaves like @code{fpngl_irng_next64}, otherwise it returns the
integer computed with @code{fpngl_irng_next32} cast to 64 bits.
@end deftypefn

@node Integer RNGs available
@section Integer RNGs available
@c ----------------------------
The number of integer Random Number Generators augments regularly with new versions of FPNGlib. @ref{tab:irngs} summarizes the characteristics of the integer RNGs implemented in the current version of the library, with the following meanings for the columns:
@itemize
@item@w{}@b{Name}. The name of the RNG as reported by @code{fpngl_irng32_name} for the 32 bits RNGs and @code{fpngl_irng64_name} for the 64 bits RNGs;
@item@w{}@b{Size}. Size, in bits, of the integers that are natively created by the RNG;
@item@w{}@b{Min}. Value of the smallest integer that can returned by the RNG;
@item@w{}@b{Max}. Value of the largest integer that can returned by the RNG;
@item@w{}@b{Period}. Number of integers that can be drawn before a sequence repeats itself.
@end itemize


@float Table,tab:irngs
@caption{Integer RNGs available in FPNGlib@tie{}@value{VERSION} and their characteristics.}
@multitable @columnfractions .4 .15 .15 .15 .15
@headitem Name @tab Size @tab Min. @tab Max. @tab Period
@item @code{drand48_lcg64} @tab 64 @tab 0 @tab @math{2^{48}-1} @tab ?
@item @code{gnu_lcg64} @tab 64 @tab 0 @tab @math{2^{31}-1} @tab ?
@item @code{minstd64} @tab 64 @tab 0 @tab @math{2^{31}-2} @tab ?
@item @code{mt19937v32} @tab 32 @tab 0 @tab @math{2^{32}-1} @tab ?
@item @code{mt19937v64} @tab 64 @tab 0 @tab @math{2^{64}-1} @tab ?
@item @code{mupad_lcg64} @tab 64 @tab 0 @tab @math{10^{12}-12} @tab ?
@item @code{randu64} @tab 64 @tab 0 @tab  @math{2^{31}-1} @tab ?
@item @code{von neumann/metropolis} @tab 32 @tab 0 @tab @math{2^{32}-1} @tab ?
@item @code{xor4096iv32} @tab 32 @tab 0 @tab @math{2^{32}-1} @tab ?
@item @code{xor4096iv64} @tab 64 @tab 0 @tab @math{2^{64}-1} @tab ?
@end multitable
@end float

@subsection 32 Bits Integer RNGs
@c .............................
The following constructors create an integer RNG initialized with a seed, which can be one integer or an array of integers.

@deftypefn {@code{"von neumann/metropolis"}} fpngl_irng32_t* fpngl_von_neumann_metropolis @
           (uint32_t @var{seed})
Create a 32 bits RNG using the algorithm described in @cite{Various techniques used in connection with random digits. John von Neumann. In A.S. Householder, G.E. Forsythe, and H.H. Germond, eds. Monte Carlo Method, National Bureau of Standards Applied Mathematics Series, vol. 12:pp. 36--38}.

The value of @var{seed} should be greater than 255, and preferably much larger than that, otherwise the RNG will only return 0.

This is not a very good RNG; it is only provided for its historical interest.
@end deftypefn

@deftypefn {@code{"mt19937v32"}} fpngl_irng32_t* fpngl_mt19937v32 (uint32_t @var{seed})
@deftypefnx {@code{"mt19937v32"}} fpngl_irng32_t* fpngl_mt19937v32_by_array @
           (const uint32_t @var{init_key[]}, uint32_t @var{key_length})
This is the 32 bits version of the Mersenne Twister MT19937 by Nishimura & Matsumoto. It can be initialized either by a single integer, or by an array of integers. For maximum entropy, the array should have a size at least equal to 624, but smaller arrays are allowed.

The function @code{fpngl_irng32_seed} returns @code{0} if the RNG is initialized with an array.
@end deftypefn

@deftypefn {@code{"xor4096iv32"}} fpngl_irng32_t* fpngl_xor4096iv32 (uint32_t @var{seed})
This is the 32 bits implementation of the @code{xor4096i} algorithm by Richard P. Brent.
@end deftypefn


@subsection 64 Bits Integer RNGs
@c .............................


@deftypefn {@code{"minstd64"}} fpngl_irng64_t*  fpngl_minstd64 (uint64_t @var{seed})
MINSTD implementation of Park & Miller Linear Congruential Generator:

@tex
$$a_i = 16807a_{i-1}\,\, {\rm mod}\,\, (2^{31}-1)$$
@end tex

See: @cite{Random Number Generators: Good Ones Are Hard to Find. S. K. Park and K.W. Miller. Comm. ACM 31(10), 1988}
@end deftypefn


@deftypefn {@code{"gnuc_lcg64"}} fpngl_irng64_t*  fpngl_gnuc_lcg64 (uint64_t @var{seed})
RNG used in the implementation of the GNU libc @code{rand} function:

@tex
$$a_i = 1103515245a_{i-1} + 12345 \,\, {\rm mod}\,\, 2^{31}$$
@end tex

This RNG is no longer the default implementation for @code{rand} in GNU libc as of v. 2.29.
@end deftypefn


@deftypefn {@code{"randu64"}} fpngl_irng64_t*  fpngl_randu64 (uint64_t @var{seed})
This is the 64 bits implementation of the RNG called ``@code{RANDU}'' in the @emph{Scientific Subroutine Package on IBM Mainframe}:

@tex
$$a_i = 65539a_{i-1} \,\, {\rm mod}\,\, 2^{31}$$
@end tex


See: @cite{Numerical Computing with MATLAB. Steve Moler. Chap. 9}.
@end deftypefn

@deftypefn {@code{"drand48_lcg64"}} fpngl_irng64_t*  fpngl_drand48_lcg64 (uint64_t @var{seed})
RNG used by the GNU and FreeBSD implementations of the function @code{drand48}. It is also used by @code{java.util.Random}. It is an LCG with formula:

@tex
$$a_i = 25214903917a_{i-1} + 11 \,\, {\rm mod}\,\, 2^{48}$$
@end tex
@end deftypefn

@deftypefn {@code{"mupad_lcg64"}} fpngl_irng64_t*  fpngl_mupad_lcg64 (uint64_t @var{seed})
RNG used in MuPAD Pro 3.1 and Maple 10. This is an LCG with formula:

@tex
$$a_i = 427419669081a_{i-1} \,\, {\rm mod}\,\, (10^{12}-11)$$
@end tex

@end deftypefn

@deftypefn {@code{"mt19937v64"}} fpngl_irng64_t* fpngl_mt19937v64 (uint64_t @var{seed})
@deftypefnx {@code{"mt19937v64"}} fpngl_irng64_t* fpngl_mt19937v64_by_array @
           (const uint64_t @var{init_key[]}, uint64_t @var{key_length})
This is the 64 bits version of the Mersenne Twister MT19937 by Nishimura & Matsumoto. It can be initialized either by a single integer, or by an array of integers. For maximum entropy, the array should have a size at least equal to 312, but smaller arrays are allowed.

The function @code{fpngl_irng_seed} returns @code{0} if the RNG is initialized with an array.
@end deftypefn

@deftypefn {@code{"xor4096iv64"}} fpngl_irng64_t* fpngl_xor4096iv64 (uint64_t @var{seed})
This is the 64 bits implementation of the @code{xor4096i} algorithm by Richard P. Brent.
@end deftypefn

@node Random Integers in a Range
@section Random Integers in a Range
@c --------------------------------

Most RNGs of @ref{Integer RNGs available} return random integers drawn from a large domain (typically @math{[0,2^{32}-1]} or @math{[0,2^{64}-1]}). Many applications, however, require random integers from much smaller domains, e.g., to model dice throwing, coin tossing, @enddots{} A much quoted tentative answer to the problem is to use the modulo operation, as in @ref{biased_dice_c,,Program @file{biased_dice.c}}. As already discussed for that program, this approach is biased whenever the number of values in the original domain of the RNG is not a multiple of the modulus. Even if it is a multiple of the modulus, the modulo operation extracts the low-order bits of the random integer, which are the least ``random'' for many RNGs.

FPNGlib offers four different functions to compute random numbers in a ``small'' domain, depending on the size of the integers required and the bounds of the domain: if the domain is of the form ``@math{[0,a)}'', use the following functions:

@deftypefn {Library Function} uint32_t fpngl_ubound32 @
           (fpngl_irng_t* @var{rng}, uint32_t @var{a})
@deftypefnx {Library Function} uint64_t fpngl_ubound64 @
            (fpngl_irng_t* @var{rng}, uint64_t @var{a})
Use the RNG @var{rng} to draw an integer uniformly at random in the domain @math{[0,a)}.

The functions use an efficient algorithm by D. Lemire presented in @cite{``Fast Random Integer Generation in an Interval.'' Daniel Lemire. ACM Transactions on Modeling and Computer Simulation, 29(1), 2019} with modifications by M.E. O'Neill proposed in @cite{``Efficiently Generating a Number in a Range''. @url{https://www.pcg-random.org/posts/bounded-rands.html}. 2018-07-22. [Retrieved 2020-03-12]}.

Function @code{fpngl_ubound64} may be slower when the computer does not offer 128 bits integers natively.
@end deftypefn

Note that, for both functions, no provision is made to ensure that @var{a} is smaller than the largest integer that can be computed by @var{rng}, @code{fpngl_irng_max(rng)}. It is up to the user to check that this precondition is met.


When the domain considered is of the form @math{[a,b)}, with @math{a} and @math{b} potentially negative integers, use the following functions:

@deftypefn {Library Function} int32_t fpngl_range32 @
           (fpngl_irng_t* @var{rng}, int32_t @var{a}, int32_t @var{b})
@deftypefnx {Library Function} int64_t fpngl_range64 @
           (fpngl_irng_t* @var{rng}, int64_t @var{a}, int64_t @var{b})
Use the RNG @var{rng} to draw integers uniformly at random in the domain @math{[@var{a},@var{b})}.

These functions rely, respectively, on functions @code{fpngl_ubound32} and @code{fpngl_ubound64} to compute random integers in the domain @math{[0, b-a)} and then shift it by @var{a}.
@end deftypefn      


@node Non-Uniform Distributions
@section Non-Uniform Distributions
@c -------------------------------

All the RNGs presented in @ref{Integer RNGs available} return integers drawn uniformly at random in their domain of definition. It is sometimes necessary to consider other distributions. At present, FPNGlib only allows to draw integers from a discrete distribution. Consider, for example, the modeling of a biased dice with the probabilities shown in @ref{fig:biased_dice}.


@float Figure,fig:biased_dice
@center @image{fpnglib-figures/discrete_distribution,3.5in,}
@caption{Biased dice modeled with a discrete probability distribution}
@end float

A discrete probability distribution is created by calling the @code{fpnlg_distribution_new} function with an integer RNG and an array of probabilities as parameters. It returns an object of type @code{fpngl_distribution_t}, which can be used to draw 32 bits random integers following the distribution embodied by the array of probabilities:

@cartouche
@verbatiminclude snippets/biased_dice_2.c
@end cartouche

@noindent The output of this program is:
@verbatim
0.0999 0.199 0.0999 0.1 0.3 0.2
@end verbatim
@noindent which is very close to the distribution we expect.

@deftypefn {Library Function} fpngl_distribution_t* fpngl_distribution_new @
           (fpngl_irng_t* @var{rng}, const double @var{P}[], uint32_t @var{szP})
Construct a discrete distribution with probability @var{P}@code{[i]} of drawing the integer @code{i}. The array @var{P} must have at least @var{szP} elements, where @var{szP} must be lower or equal to @math{2^{30}} (The limit on @var{szP} is due to the use of the @code{uistack_t} type, which has a similar implementation-motivated limit). The sum of all values in @var{P} must be equal to 1.
          
The current implementation uses the Walker/Vose alias method with linear complexity(@cite{``An Efficient Method for Generating Discrete Random Variables with General Distributions.'' A.J. Walker. ACM Transactions on Mathematical Software. 3 (3): 253–256, 1977} and @cite{``A linear algorithm for generating random numbers with a given distribution.'' M.D. Vose. IEEE Transactions on Software Engineering. 17 (9): 972–975}).

The ownership of the integer RNG @var{rng} is transferred to the @code{fpngl_distribution_t} object, which is responsible for its disposal.
@end deftypefn

@deftypefn {Library Function} void fpngl_distribution_delete @
           (fpngl_distribution_t* @var{dist})
Reclaim the memory allocated to represent a discrete distribution. It also reclaims the memory used to represent the RNG passed upon its construction.
@end deftypefn

@deftypefn {Library Function} uint32_t fpngl_distribution_next32 @
           (fpngl_distribution_t *@var{dist})
Return a random 32 bits integer according to the discrete distribution @var{dist}.
@end deftypefn

@node Floating-Point Random Generators
@chapter Floating-Point Random Generators
@c ======================================





@node IEEE 754 and the Floating-Point Unit
@chapter IEEE 754 and the Floating-Point Unit
@c ==========================================

That chapter describes the various constants, functions and macros provided by FPNGlib that do not directly contribute to the generation of random numbers. 

@section Constants
@c ---------------

Several constants related to the characteristics of the IEEE@tie{}754 floating-point
format are defined in files @file{fpnglib/constants32.h} ---for the single precision---
and @file{fpnglib/constants64.h} ---for the double precision.

@deftypevr Constant uint32_t fpngl_emin32
@deftypevrx Constant uint32_t fpngl_emin64
@deftypevrx Constant uint32_t fpngl_emax32
@deftypevrx Constant uint32_t fpngl_emax64
Smallest and largest unbiased exponents for single and double precision float.
@noindent @strong{Example}
@cartouche
@verbatiminclude snippets/exponent.c
@end cartouche
@noindent @strong{Output:}
@verbatim
Single precision exponent in [-126, 127]
Double precision exponent in [-1022, 1023]
@end verbatim
@end deftypevr

@deftypevr Constant uint32_t fpngl_t32
@deftypevrx Constant uint32_t fpngl_t64
Number of bits in the significand of a single or double precision float.
@noindent @strong{Example:}
@cartouche
@verbatiminclude snippets/significand.c
@end cartouche
@noindent @strong{Output:}
@verbatim
Number of digits with single precision: 7
Number of digits with double precision: 15
@end verbatim
@end deftypevr

@deftypevr Constant float fpngl_mu32
@deftypevrx Constant double fpngl_mu64
Smallest positive float. This is a subnormal number.
@noindent@b{Example:}
@cartouche
@verbatiminclude snippets/mu.c
@end cartouche
@noindent@b{Output:}
@verbatim
1
1
@end verbatim
@end deftypevr

@deftypevr Constant float fpngl_lambda32
@deftypevrx Constant double fpngl_lambda64
Smallest positive normal float.
@noindent@b{Example:}
@cartouche
@verbatiminclude snippets/lambda.c
@end cartouche
@noindent@b{Output:}
@verbatim
Single precision smallest positive normal: 1.17549e-38
Double precision smallest positive normal: 2.22507e-308
@end verbatim
@end deftypevr

@deftypevr Constant float fpngl_u32
@deftypevrx Constant double fpngl_u64
@dfn{Unit roundoff}, which is half the distance between @code{1.0} and the next floating-point number.
@noindent@b{Example:}
@cartouche
@verbatiminclude snippets/unitroundoff.c
@end cartouche
@noindent@b{Output:}
@verbatim
Single precision unit roundoff: 5.96046e-08
Double precision unit roundoff: 1.11022e-16
@end verbatim
@end deftypevr

@deftypevr Constant float fpngl_max32
@deftypevrx Constant double fpngl_max64
Largest positive float smaller than the ``infinity'' value.
@noindent@b{Example:}
@cartouche
@verbatiminclude snippets/max.c
@end cartouche
@noindent@b{Output:}
@verbatim
Single precision largest float: 3.40282e+38
Double precision largest float: 1.79769e+308
@end verbatim
@end deftypevr

@deftypevr Constant float fpngl_NaN32
@deftypevrx Constant double fpngl_NaN64
Return a @emph{Not a Number}.
@noindent@b{Example:}
@cartouche
@verbatiminclude snippets/nan.c
@end cartouche
@noindent@b{Output:}
@verbatim
Single precision NaN: nan
Double precision NaN: nan
@end verbatim
@end deftypevr

@deftypevr Constant float fpngl_infinity32
@deftypevrx Constant double fpngl_infinity64
Infinity value.
@noindent@b{Example:}
@cartouche
@verbatiminclude snippets/inf.c
@end cartouche
@noindent@b{Output:}
@verbatim
Single precision infinity: inf
Double precision infinity: inf
@end verbatim
@end deftypevr

@deftypevr Constant uint64_t fpngl_minfrac64
@deftypevrx Constant uint64_t fpngl_maxfrac64
Minimum and maximum value for the fractional part of a 64 bits double precision floating-point number. These constants are mainly used when calling @code{fpngl_float64} to draw floats with some properties.
@noindent@b{Example:}
@cartouche
@verbatiminclude snippets/minmaxfrac.c
@end cartouche
@noindent@b{Output:}
@verbatim
minfrac64: 0
maxfrac64: fffffffffffff
@end verbatim
@end deftypevr

@deftypevr Constant uint64_t fpngl_noand64
@deftypevrx Constant uint64_t fpngl_noor64
Masks to use with the function @code{fpng_float64} when no @emph{and} mask
(resp.@tie{}no @emph{or} mask) is needed for the fractional part of the floats
constructed.
@noindent@b{Example:}
@cartouche
@verbatiminclude snippets/noandor.c
@end cartouche
@noindent@b{Output:}
@verbatim
noand64 mask: ffffffffffffffff
noor64 mask: 0
@end verbatim
@end deftypevr

@section Utility Functions
@c -----------------------

FPNGlib defines functions that can aid in computing the floating-point numbers an application requires. They are:

@deftypefn {Library Function} double fpngl_nextafter64 (double @var{v}, uint64_t @var{n})
Return a double precision number that is @var{n} floating-point numbers @emph{after}
@var{v} on the real line.

The value of @var{n} must be smaller or equal to @code{0xffe0000000000000}. The function will abort if @var{n} is greater than that @b{and} the library has been compiled with @option{--enable-debug=yes}.

If @var{v} is an NaN, the function returns the same NaN. Otherwise, it returns either a finite float or a positive infinite, depending on the value of @var{n} and the distance of @var{v} to the maximum representable double precision float.

@noindent@b{Example:}
@cartouche
@verbatiminclude snippets/nextafter64.c
@end cartouche
The output is @code{1} since there are @math{2^{52}} floats from @code{1.0} to @code{2.0} in double precision.
@end deftypefn


@deftypefn {Library Function} double fpngl_previous64 (double @var{v}, uint64_t @var{n})
Return a double precision number that is @var{n} floating-point numbers @emph{before}
@var{v} on the real line.

The value of @var{n} must be smaller or equal to @code{0xffe0000000000000}. The function will abort if @var{n} is greater than that @b{and} the library has been compiled with @option{--enable-debug=yes}.

If @var{v} is an NaN, the function returns the same NaN. Otherwise, it returns either a finite float or a positive infinite, depending on the value of @var{n} and the distance of @var{v} to the maximum representable double precision float.

@noindent@b{Example:}
@cartouche
@verbatiminclude snippets/previous64.c
@end cartouche
The output is @code{1} since the smallest positive double precision float is separated from the largest negative float by @code{0}.
@end deftypefn

@section Manipulating the FPU 
@c ------------------------

@node Extending the Library
@chapter Extending the Library
@c ===========================
The library is written with an object-oriented style that should make it easy to extend.

@float Figure,fig:classes
@image{fpnglib-figures/classes,6in,}
@caption{The ``classes'' of FPNGlib}
@end float

Functions with ``@code{_internal}'' in their name are for internal use in the library and should not be used outside of its realm.

@section Debugging facilities
@c --------------------------

FPNGlib offers facilities to debug itself. There are in particular some macros that can be used to display messages to the standard error ouput @code{stderr}, provided the library was configured with the option @option{--enable-debug=yes} (the default) or @option{--enable-debug=info} for some macros.

@deffn Macro FPNGL_DEBUG (...)
Uses @code{fprintf} to output its arguments to @code{stderr} if the macro @code{NDEBUG}
is defined to @code{1}. Otherwise, it does nothing.

The macro flushes the output buffer with @code{fflush} after each call.

@noindent@b{Example:}
@cartouche
@verbatiminclude snippets/debug.c
@end cartouche
@end deffn

@deffn Macro FPNGL_WARNING (...)
Displays a warning message to @code{stderr} if the library was configured with either
@option{--enable-debug=yes} or @option{--enable-debug=info}.

The macro flushes the output buffer with @code{fflush} after each call.

@noindent@b{Example:}
@cartouche
@verbatiminclude snippets/warning.c
@end cartouche
@end deffn

@section Adding new IRNGs
@c ----------------------

@deftypefn {Library Function} fpngl_irng32_t* fpngl_irng32_new @
           (uint32_t @var{seed},
            const char* @var{name},
						uint32_t @var{min}, uint32_t @var{max},
						void* @var{state},
						void* (*@var{copy_state})(void*),
						uint32_t (*@var{next32})(void*),
						uint64_t (*@var{next64})(void*),
						uint32_t (*@var{nextk})(void*, uint32_t),
						void (*@var{next_array32})(void *, uint32_t *, uint32_t),
  					void (*@var{next_array64})(void *, uint64_t *, uint32_t),
						void (*@var{delete})(void*))
@c TODO            
@end deftypefn   

@section Miscellaneous Supporting Code
@c -----------------------------------

@c Describe uistack

@node Function Index
@chapter Function Index
@c ====================
@printindex fn

@node Type Index
@chapter Type Index
@c ================
@printindex tp

@node Concept Index
@chapter Concept Index
@c ===================
@printindex cp

@bye

@c Local Variables:
@c mode: texinfo
@c TeX-master: t
@c End:
